// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Unused Import Test > GIVEN a file that imports from a module exporting a node builtin and does not use it THEN it should be removed by esbuild 1`] = `
"// node-modules-polyfills:node:zlib
var exports$2 = {};
var _dewExec$2 = false;
function dew$2() {
  if (_dewExec$2) return exports$2;
  _dewExec$2 = true;
  exports$2.byteLength = byteLength;
  exports$2.toByteArray = toByteArray;
  exports$2.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i42 = 0, len = code.length; i42 < len; ++i42) {
    lookup[i42] = code[i42];
    revLookup[code.charCodeAt(i42)] = i42;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i5;
    for (i5 = 0; i5 < len2; i5 += 4) {
      tmp = revLookup[b64.charCodeAt(i5)] << 18 | revLookup[b64.charCodeAt(i5 + 1)] << 12 | revLookup[b64.charCodeAt(i5 + 2)] << 6 | revLookup[b64.charCodeAt(i5 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i5)] << 2 | revLookup[b64.charCodeAt(i5 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i5)] << 10 | revLookup[b64.charCodeAt(i5 + 1)] << 4 | revLookup[b64.charCodeAt(i5 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i5 = start; i5 < end; i5 += 3) {
      tmp = (uint8[i5] << 16 & 16711680) + (uint8[i5 + 1] << 8 & 65280) + (uint8[i5 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i5 = 0, len22 = len2 - extraBytes; i5 < len22; i5 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i5, i5 + maxChunkLength > len22 ? len22 : i5 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$2;
}
var exports$1 = {};
var _dewExec$1 = false;
function dew$1() {
  if (_dewExec$1) return exports$1;
  _dewExec$1 = true;
  exports$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e5, m4;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i42 = isLE ? nBytes - 1 : 0;
    var d4 = isLE ? -1 : 1;
    var s42 = buffer2[offset + i42];
    i42 += d4;
    e5 = s42 & (1 << -nBits) - 1;
    s42 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e5 = e5 * 256 + buffer2[offset + i42], i42 += d4, nBits -= 8) {
    }
    m4 = e5 & (1 << -nBits) - 1;
    e5 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m4 = m4 * 256 + buffer2[offset + i42], i42 += d4, nBits -= 8) {
    }
    if (e5 === 0) {
      e5 = 1 - eBias;
    } else if (e5 === eMax) {
      return m4 ? NaN : (s42 ? -1 : 1) * Infinity;
    } else {
      m4 = m4 + Math.pow(2, mLen);
      e5 = e5 - eBias;
    }
    return (s42 ? -1 : 1) * m4 * Math.pow(2, e5 - mLen);
  };
  exports$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e5, m4, c42;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i42 = isLE ? 0 : nBytes - 1;
    var d4 = isLE ? 1 : -1;
    var s42 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m4 = isNaN(value) ? 1 : 0;
      e5 = eMax;
    } else {
      e5 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c42 = Math.pow(2, -e5)) < 1) {
        e5--;
        c42 *= 2;
      }
      if (e5 + eBias >= 1) {
        value += rt / c42;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c42 >= 2) {
        e5++;
        c42 /= 2;
      }
      if (e5 + eBias >= eMax) {
        m4 = 0;
        e5 = eMax;
      } else if (e5 + eBias >= 1) {
        m4 = (value * c42 - 1) * Math.pow(2, mLen);
        e5 = e5 + eBias;
      } else {
        m4 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e5 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i42] = m4 & 255, i42 += d4, m4 /= 256, mLen -= 8) {
    }
    e5 = e5 << mLen | m4;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i42] = e5 & 255, i42 += d4, e5 /= 256, eLen -= 8) {
    }
    buffer2[offset + i42 - d4] |= s42 * 128;
  };
  return exports$1;
}
var exports = {};
var _dewExec = false;
function dew() {
  if (_dewExec) return exports;
  _dewExec = true;
  const base64 = dew$2();
  const ieee754 = dew$1();
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by \`buffer\` v5.x. Use \`buffer\` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e5) {
      return false;
    }
  }
  Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length);
    }
    const b4 = fromObject(value);
    if (b4) return b4;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i42 = 0; i42 < length; i42 += 1) {
      buf[i42] = array[i42] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer.alloc(+length);
  }
  Buffer.isBuffer = function isBuffer(b4) {
    return b4 != null && b4._isBuffer === true && b4 !== Buffer.prototype;
  };
  Buffer.compare = function compare(a42, b4) {
    if (isInstance(a42, Uint8Array)) a42 = Buffer.from(a42, a42.offset, a42.byteLength);
    if (isInstance(b4, Uint8Array)) b4 = Buffer.from(b4, b4.offset, b4.byteLength);
    if (!Buffer.isBuffer(a42) || !Buffer.isBuffer(b4)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a42 === b4) return 0;
    let x4 = a42.length;
    let y5 = b4.length;
    for (let i42 = 0, len = Math.min(x4, y5); i42 < len; ++i42) {
      if (a42[i42] !== b4[i42]) {
        x4 = a42[i42];
        y5 = b4[i42];
        break;
      }
    }
    if (x4 < y5) return -1;
    if (y5 < x4) return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer.alloc(0);
    }
    let i42;
    if (length === void 0) {
      length = 0;
      for (i42 = 0; i42 < list.length; ++i42) {
        length += list[i42].length;
      }
    }
    const buffer2 = Buffer.allocUnsafe(length);
    let pos = 0;
    for (i42 = 0; i42 < list.length; ++i42) {
      let buf = list[i42];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype._isBuffer = true;
  function swap(b4, n42, m4) {
    const i42 = b4[n42];
    b4[n42] = b4[m4];
    b4[m4] = i42;
  }
  Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i42 = 0; i42 < len; i42 += 2) {
      swap(this, i42, i42 + 1);
    }
    return this;
  };
  Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i42 = 0; i42 < len; i42 += 4) {
      swap(this, i42, i42 + 3);
      swap(this, i42 + 1, i42 + 2);
    }
    return this;
  };
  Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i42 = 0; i42 < len; i42 += 8) {
      swap(this, i42, i42 + 7);
      swap(this, i42 + 1, i42 + 6);
      swap(this, i42 + 2, i42 + 5);
      swap(this, i42 + 3, i42 + 4);
    }
    return this;
  };
  Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.toLocaleString = Buffer.prototype.toString;
  Buffer.prototype.equals = function equals(b4) {
    if (!Buffer.isBuffer(b4)) throw new TypeError("Argument must be a Buffer");
    if (this === b4) return true;
    return Buffer.compare(this, b4) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
  }
  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x4 = thisEnd - thisStart;
    let y5 = end - start;
    const len = Math.min(x4, y5);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i42 = 0; i42 < len; ++i42) {
      if (thisCopy[i42] !== targetCopy[i42]) {
        x4 = thisCopy[i42];
        y5 = targetCopy[i42];
        break;
      }
    }
    if (x4 < y5) return -1;
    if (y5 < x4) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer.from(val, encoding);
    }
    if (Buffer.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i5) {
      if (indexSize === 1) {
        return buf[i5];
      } else {
        return buf.readUInt16BE(i5 * indexSize);
      }
    }
    let i42;
    if (dir) {
      let foundIndex = -1;
      for (i42 = byteOffset; i42 < arrLength; i42++) {
        if (read(arr, i42) === read(val, foundIndex === -1 ? 0 : i42 - foundIndex)) {
          if (foundIndex === -1) foundIndex = i42;
          if (i42 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i42 -= i42 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i42 = byteOffset; i42 >= 0; i42--) {
        let found = true;
        for (let j4 = 0; j4 < valLength; j4++) {
          if (read(arr, i42 + j4) !== read(val, j4)) {
            found = false;
            break;
          }
        }
        if (found) return i42;
      }
    }
    return -1;
  }
  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i42;
    for (i42 = 0; i42 < length; ++i42) {
      const parsed = parseInt(string.substr(i42 * 2, 2), 16);
      if (numberIsNaN(parsed)) return i42;
      buf[offset + i42] = parsed;
    }
    return i42;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i42 = start;
    while (i42 < end) {
      const firstByte = buf[i42];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i42 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i42 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i42 + 1];
            thirdByte = buf[i42 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i42 + 1];
            thirdByte = buf[i42 + 2];
            fourthByte = buf[i42 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i42 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i42 = 0;
    while (i42 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i42, i42 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i42 = start; i42 < end; ++i42) {
      ret += String.fromCharCode(buf[i42] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i42 = start; i42 < end; ++i42) {
      ret += String.fromCharCode(buf[i42]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i42 = start; i42 < end; ++i42) {
      out += hexSliceLookupTable[buf[i42]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i42 = 0; i42 < bytes.length - 1; i42 += 2) {
      res += String.fromCharCode(bytes[i42] + bytes[i42 + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i42 = 0;
    while (++i42 < byteLength2 && (mul *= 256)) {
      val += this[offset + i42] * mul;
    }
    return val;
  };
  Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i42 = 0;
    while (++i42 < byteLength2 && (mul *= 256)) {
      val += this[offset + i42] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let i42 = byteLength2;
    let mul = 1;
    let val = this[offset + --i42];
    while (i42 > 0 && (mul *= 256)) {
      val += this[offset + --i42] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i42 = 0;
    this[offset] = value & 255;
    while (++i42 < byteLength2 && (mul *= 256)) {
      this[offset + i42] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i42 = byteLength2 - 1;
    let mul = 1;
    this[offset + i42] = value & 255;
    while (--i42 >= 0 && (mul *= 256)) {
      this[offset + i42] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i42 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i42 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i42 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i42] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i42 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i42] = value & 255;
    while (--i42 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i42 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i42] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i42;
    if (typeof val === "number") {
      for (i42 = start; i42 < end; ++i42) {
        this[i42] = val;
      }
    } else {
      const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i42 = 0; i42 < end - start; ++i42) {
        this[i42 + start] = bytes[i42 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E4(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = \`\${this.name} [\${sym}]\`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return \`\${this.name} [\${sym}]: \${this.message}\`;
      }
    };
  }
  E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2) {
      return \`\${name2} is outside of buffer bounds\`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E4("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return \`The "\${name2}" argument must be of type number. Received type \${typeof actual}\`;
  }, TypeError);
  E4("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = \`The value of "\${str}" is out of range.\`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += \` It must be \${range}. Received \${received}\`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i42 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i42 >= start + 4; i42 -= 3) {
      res = \`_\${val.slice(i42 - 3, i42)}\${res}\`;
    }
    return \`\${val.slice(0, i42)}\${res}\`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n42 = typeof min === "bigint" ? "n" : "";
      let range;
      {
        if (min === 0 || min === BigInt(0)) {
          range = \`>= 0\${n42} and < 2\${n42} ** \${(byteLength2 + 1) * 8}\${n42}\`;
        } else {
          range = \`>= -(2\${n42} ** \${(byteLength2 + 1) * 8 - 1}\${n42}) and < 2 ** \${(byteLength2 + 1) * 8 - 1}\${n42}\`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE("offset", \`>= \${0} and <= \${length}\`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i42 = 0; i42 < length; ++i42) {
      codePoint = string.charCodeAt(i42);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i42 + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i42 = 0; i42 < str.length; ++i42) {
      byteArray.push(str.charCodeAt(i42) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c42, hi, lo;
    const byteArray = [];
    for (let i42 = 0; i42 < str.length; ++i42) {
      if ((units -= 2) < 0) break;
      c42 = str.charCodeAt(i42);
      hi = c42 >> 8;
      lo = c42 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i42;
    for (i42 = 0; i42 < length; ++i42) {
      if (i42 + offset >= dst.length || i42 >= src.length) break;
      dst[i42 + offset] = src[i42];
    }
    return i42;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i42 = 0; i42 < 16; ++i42) {
      const i16 = i42 * 16;
      for (let j4 = 0; j4 < 16; ++j4) {
        table[i16 + j4] = alphabet[i42] + alphabet[j4];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports;
}
var e;
var t;
var n = "object" == typeof Reflect ? Reflect : null;
var r = n && "function" == typeof n.apply ? n.apply : function(e5, t5, n42) {
  return Function.prototype.apply.call(e5, t5, n42);
};
t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e5) {
  return Object.getOwnPropertyNames(e5).concat(Object.getOwnPropertySymbols(e5));
} : function(e5) {
  return Object.getOwnPropertyNames(e5);
};
var i = Number.isNaN || function(e5) {
  return e5 != e5;
};
function o() {
  o.init.call(this);
}
e = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var s = 10;
function u(e5) {
  if ("function" != typeof e5) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e5);
}
function f(e5) {
  return void 0 === e5._maxListeners ? o.defaultMaxListeners : e5._maxListeners;
}
function v(e5, t5, n42, r5) {
  var i42, o42, s42, v5;
  if (u(n42), void 0 === (o42 = e5._events) ? (o42 = e5._events = /* @__PURE__ */ Object.create(null), e5._eventsCount = 0) : (void 0 !== o42.newListener && (e5.emit("newListener", t5, n42.listener ? n42.listener : n42), o42 = e5._events), s42 = o42[t5]), void 0 === s42) s42 = o42[t5] = n42, ++e5._eventsCount;
  else if ("function" == typeof s42 ? s42 = o42[t5] = r5 ? [n42, s42] : [s42, n42] : r5 ? s42.unshift(n42) : s42.push(n42), (i42 = f(e5)) > 0 && s42.length > i42 && !s42.warned) {
    s42.warned = true;
    var a42 = new Error("Possible EventEmitter memory leak detected. " + s42.length + " " + String(t5) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a42.name = "MaxListenersExceededWarning", a42.emitter = e5, a42.type = t5, a42.count = s42.length, v5 = a42, console && console.warn && console.warn(v5);
  }
  return e5;
}
function a() {
  if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function l(e5, t5, n42) {
  var r5 = { fired: false, wrapFn: void 0, target: e5, type: t5, listener: n42 }, i42 = a.bind(r5);
  return i42.listener = n42, r5.wrapFn = i42, i42;
}
function h(e5, t5, n42) {
  var r5 = e5._events;
  if (void 0 === r5) return [];
  var i42 = r5[t5];
  return void 0 === i42 ? [] : "function" == typeof i42 ? n42 ? [i42.listener || i42] : [i42] : n42 ? function(e6) {
    for (var t6 = new Array(e6.length), n5 = 0; n5 < t6.length; ++n5) t6[n5] = e6[n5].listener || e6[n5];
    return t6;
  }(i42) : c(i42, i42.length);
}
function p(e5) {
  var t5 = this._events;
  if (void 0 !== t5) {
    var n42 = t5[e5];
    if ("function" == typeof n42) return 1;
    if (void 0 !== n42) return n42.length;
  }
  return 0;
}
function c(e5, t5) {
  for (var n42 = new Array(t5), r5 = 0; r5 < t5; ++r5) n42[r5] = e5[r5];
  return n42;
}
Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
  return s;
}, set: function(e5) {
  if ("number" != typeof e5 || e5 < 0 || i(e5)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e5 + ".");
  s = e5;
} }), o.init = function() {
  void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(e5) {
  if ("number" != typeof e5 || e5 < 0 || i(e5)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e5 + ".");
  return this._maxListeners = e5, this;
}, o.prototype.getMaxListeners = function() {
  return f(this);
}, o.prototype.emit = function(e5) {
  for (var t5 = [], n42 = 1; n42 < arguments.length; n42++) t5.push(arguments[n42]);
  var i42 = "error" === e5, o42 = this._events;
  if (void 0 !== o42) i42 = i42 && void 0 === o42.error;
  else if (!i42) return false;
  if (i42) {
    var s42;
    if (t5.length > 0 && (s42 = t5[0]), s42 instanceof Error) throw s42;
    var u42 = new Error("Unhandled error." + (s42 ? " (" + s42.message + ")" : ""));
    throw u42.context = s42, u42;
  }
  var f42 = o42[e5];
  if (void 0 === f42) return false;
  if ("function" == typeof f42) r(f42, this, t5);
  else {
    var v5 = f42.length, a42 = c(f42, v5);
    for (n42 = 0; n42 < v5; ++n42) r(a42[n42], this, t5);
  }
  return true;
}, o.prototype.addListener = function(e5, t5) {
  return v(this, e5, t5, false);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e5, t5) {
  return v(this, e5, t5, true);
}, o.prototype.once = function(e5, t5) {
  return u(t5), this.on(e5, l(this, e5, t5)), this;
}, o.prototype.prependOnceListener = function(e5, t5) {
  return u(t5), this.prependListener(e5, l(this, e5, t5)), this;
}, o.prototype.removeListener = function(e5, t5) {
  var n42, r5, i42, o42, s42;
  if (u(t5), void 0 === (r5 = this._events)) return this;
  if (void 0 === (n42 = r5[e5])) return this;
  if (n42 === t5 || n42.listener === t5) 0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r5[e5], r5.removeListener && this.emit("removeListener", e5, n42.listener || t5));
  else if ("function" != typeof n42) {
    for (i42 = -1, o42 = n42.length - 1; o42 >= 0; o42--) if (n42[o42] === t5 || n42[o42].listener === t5) {
      s42 = n42[o42].listener, i42 = o42;
      break;
    }
    if (i42 < 0) return this;
    0 === i42 ? n42.shift() : !function(e6, t6) {
      for (; t6 + 1 < e6.length; t6++) e6[t6] = e6[t6 + 1];
      e6.pop();
    }(n42, i42), 1 === n42.length && (r5[e5] = n42[0]), void 0 !== r5.removeListener && this.emit("removeListener", e5, s42 || t5);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e5) {
  var t5, n42, r5;
  if (void 0 === (n42 = this._events)) return this;
  if (void 0 === n42.removeListener) return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n42[e5] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n42[e5]), this;
  if (0 === arguments.length) {
    var i42, o42 = Object.keys(n42);
    for (r5 = 0; r5 < o42.length; ++r5) "removeListener" !== (i42 = o42[r5]) && this.removeAllListeners(i42);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if ("function" == typeof (t5 = n42[e5])) this.removeListener(e5, t5);
  else if (void 0 !== t5) for (r5 = t5.length - 1; r5 >= 0; r5--) this.removeListener(e5, t5[r5]);
  return this;
}, o.prototype.listeners = function(e5) {
  return h(this, e5, true);
}, o.prototype.rawListeners = function(e5) {
  return h(this, e5, false);
}, o.listenerCount = function(e5, t5) {
  return "function" == typeof e5.listenerCount ? e5.listenerCount(t5) : p.call(e5, t5);
}, o.prototype.listenerCount = p, o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? t(this._events) : [];
};
var y = e;
y.EventEmitter;
y.defaultMaxListeners;
y.init;
y.listenerCount;
y.EventEmitter;
y.defaultMaxListeners;
y.init;
y.listenerCount;
y.once = function(emitter, event) {
  return new Promise((resolve, reject) => {
    function eventListener(...args) {
      if (errorListener !== void 0) {
        emitter.removeListener("error", errorListener);
      }
      resolve(args);
    }
    let errorListener;
    if (event !== "error") {
      errorListener = (err) => {
        emitter.removeListener(name, eventListener);
        reject(err);
      };
      emitter.once("error", errorListener);
    }
    emitter.once(event, eventListener);
  });
};
y.on = function(emitter, event) {
  const unconsumedEventValues = [];
  const unconsumedPromises = [];
  let error = null;
  let finished = false;
  const iterator = {
    async next() {
      const value = unconsumedEventValues.shift();
      if (value) {
        return createIterResult(value, false);
      }
      if (error) {
        const p42 = Promise.reject(error);
        error = null;
        return p42;
      }
      if (finished) {
        return createIterResult(void 0, true);
      }
      return new Promise((resolve, reject) => unconsumedPromises.push({ resolve, reject }));
    },
    async return() {
      emitter.removeListener(event, eventHandler);
      emitter.removeListener("error", errorHandler);
      finished = true;
      for (const promise of unconsumedPromises) {
        promise.resolve(createIterResult(void 0, true));
      }
      return createIterResult(void 0, true);
    },
    throw(err) {
      error = err;
      emitter.removeListener(event, eventHandler);
      emitter.removeListener("error", errorHandler);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  emitter.on(event, eventHandler);
  emitter.on("error", errorHandler);
  return iterator;
  function eventHandler(...args) {
    const promise = unconsumedPromises.shift();
    if (promise) {
      promise.resolve(createIterResult(args, false));
    } else {
      unconsumedEventValues.push(args);
    }
  }
  function errorHandler(err) {
    finished = true;
    const toError = unconsumedPromises.shift();
    if (toError) {
      toError.reject(err);
    } else {
      error = err;
    }
    iterator.return();
  }
};
var e$2;
var t$3;
var n$2;
var r$2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
var o$3 = e$2 = {};
function i$2() {
  throw new Error("setTimeout has not been defined");
}
function u$2() {
  throw new Error("clearTimeout has not been defined");
}
function c$2(e5) {
  if (t$3 === setTimeout) return setTimeout(e5, 0);
  if ((t$3 === i$2 || !t$3) && setTimeout) return t$3 = setTimeout, setTimeout(e5, 0);
  try {
    return t$3(e5, 0);
  } catch (n42) {
    try {
      return t$3.call(null, e5, 0);
    } catch (n5) {
      return t$3.call(this || r$2, e5, 0);
    }
  }
}
!function() {
  try {
    t$3 = "function" == typeof setTimeout ? setTimeout : i$2;
  } catch (e5) {
    t$3 = i$2;
  }
  try {
    n$2 = "function" == typeof clearTimeout ? clearTimeout : u$2;
  } catch (e5) {
    n$2 = u$2;
  }
}();
var l$2;
var s$1 = [];
var f$1 = false;
var a$1 = -1;
function h$1() {
  f$1 && l$2 && (f$1 = false, l$2.length ? s$1 = l$2.concat(s$1) : a$1 = -1, s$1.length && d$1());
}
function d$1() {
  if (!f$1) {
    var e5 = c$2(h$1);
    f$1 = true;
    for (var t5 = s$1.length; t5; ) {
      for (l$2 = s$1, s$1 = []; ++a$1 < t5; ) l$2 && l$2[a$1].run();
      a$1 = -1, t5 = s$1.length;
    }
    l$2 = null, f$1 = false, function(e6) {
      if (n$2 === clearTimeout) return clearTimeout(e6);
      if ((n$2 === u$2 || !n$2) && clearTimeout) return n$2 = clearTimeout, clearTimeout(e6);
      try {
        n$2(e6);
      } catch (t6) {
        try {
          return n$2.call(null, e6);
        } catch (t7) {
          return n$2.call(this || r$2, e6);
        }
      }
    }(e5);
  }
}
function m$1(e5, t5) {
  (this || r$2).fun = e5, (this || r$2).array = t5;
}
function p$1() {
}
o$3.nextTick = function(e5) {
  var t5 = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var n42 = 1; n42 < arguments.length; n42++) t5[n42 - 1] = arguments[n42];
  s$1.push(new m$1(e5, t5)), 1 !== s$1.length || f$1 || c$2(d$1);
}, m$1.prototype.run = function() {
  (this || r$2).fun.apply(null, (this || r$2).array);
}, o$3.title = "browser", o$3.browser = true, o$3.env = {}, o$3.argv = [], o$3.version = "", o$3.versions = {}, o$3.on = p$1, o$3.addListener = p$1, o$3.once = p$1, o$3.off = p$1, o$3.removeListener = p$1, o$3.removeAllListeners = p$1, o$3.emit = p$1, o$3.prependListener = p$1, o$3.prependOnceListener = p$1, o$3.listeners = function(e5) {
  return [];
}, o$3.binding = function(e5) {
  throw new Error("process.binding is not supported");
}, o$3.cwd = function() {
  return "/";
}, o$3.chdir = function(e5) {
  throw new Error("process.chdir is not supported");
}, o$3.umask = function() {
  return 0;
};
var T$1 = e$2;
T$1.addListener;
T$1.argv;
T$1.binding;
T$1.browser;
T$1.chdir;
T$1.cwd;
T$1.emit;
T$1.env;
T$1.listeners;
T$1.nextTick;
T$1.off;
T$1.on;
T$1.once;
T$1.prependListener;
T$1.prependOnceListener;
T$1.removeAllListeners;
T$1.removeListener;
T$1.title;
T$1.umask;
T$1.version;
T$1.versions;
var t2 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
var e2 = Object.prototype.toString;
var o2 = function(o42) {
  return !(t2 && o42 && "object" == typeof o42 && Symbol.toStringTag in o42) && "[object Arguments]" === e2.call(o42);
};
var n2 = function(t5) {
  return !!o2(t5) || null !== t5 && "object" == typeof t5 && "number" == typeof t5.length && t5.length >= 0 && "[object Array]" !== e2.call(t5) && "[object Function]" === e2.call(t5.callee);
};
var r2 = function() {
  return o2(arguments);
}();
o2.isLegacyArguments = n2;
var l2 = r2 ? o2 : n2;
var t$1 = Object.prototype.toString;
var o$1 = Function.prototype.toString;
var n$1 = /^\\s*(?:function)?\\*/;
var e$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
var r$1 = Object.getPrototypeOf;
var c2 = function() {
  if (!e$1) return false;
  try {
    return Function("return function*() {}")();
  } catch (t5) {
  }
}();
var u2 = c2 ? r$1(c2) : {};
var i2 = function(c42) {
  return "function" == typeof c42 && (!!n$1.test(o$1.call(c42)) || (e$1 ? r$1(c42) === u2 : "[object GeneratorFunction]" === t$1.call(c42)));
};
var t$2 = "function" == typeof Object.create ? function(t5, e5) {
  e5 && (t5.super_ = e5, t5.prototype = Object.create(e5.prototype, { constructor: { value: t5, enumerable: false, writable: true, configurable: true } }));
} : function(t5, e5) {
  if (e5) {
    t5.super_ = e5;
    var o42 = function() {
    };
    o42.prototype = e5.prototype, t5.prototype = new o42(), t5.prototype.constructor = t5;
  }
};
var i$1 = function(e5) {
  return e5 && "object" == typeof e5 && "function" == typeof e5.copy && "function" == typeof e5.fill && "function" == typeof e5.readUInt8;
};
var o$2 = {};
var u$1 = i$1;
var f2 = l2;
var a2 = i2;
function c$1(e5) {
  return e5.call.bind(e5);
}
var s2 = "undefined" != typeof BigInt;
var p2 = "undefined" != typeof Symbol;
var y2 = p2 && void 0 !== Symbol.toStringTag;
var l$1 = "undefined" != typeof Uint8Array;
var d = "undefined" != typeof ArrayBuffer;
if (l$1 && y2) var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
var m = c$1(Object.prototype.toString);
var h2 = c$1(Number.prototype.valueOf);
var j = c$1(String.prototype.valueOf);
var A = c$1(Boolean.prototype.valueOf);
if (s2) var w = c$1(BigInt.prototype.valueOf);
if (p2) var v2 = c$1(Symbol.prototype.valueOf);
function O(e5, t5) {
  if ("object" != typeof e5) return false;
  try {
    return t5(e5), true;
  } catch (e6) {
    return false;
  }
}
function S(e5) {
  return l$1 && y2 ? void 0 !== b(e5) : B(e5) || k(e5) || E(e5) || D(e5) || U(e5) || P(e5) || x(e5) || I(e5) || M(e5) || z(e5) || F(e5);
}
function B(e5) {
  return l$1 && y2 ? "Uint8Array" === b(e5) : "[object Uint8Array]" === m(e5) || u$1(e5) && void 0 !== e5.buffer;
}
function k(e5) {
  return l$1 && y2 ? "Uint8ClampedArray" === b(e5) : "[object Uint8ClampedArray]" === m(e5);
}
function E(e5) {
  return l$1 && y2 ? "Uint16Array" === b(e5) : "[object Uint16Array]" === m(e5);
}
function D(e5) {
  return l$1 && y2 ? "Uint32Array" === b(e5) : "[object Uint32Array]" === m(e5);
}
function U(e5) {
  return l$1 && y2 ? "Int8Array" === b(e5) : "[object Int8Array]" === m(e5);
}
function P(e5) {
  return l$1 && y2 ? "Int16Array" === b(e5) : "[object Int16Array]" === m(e5);
}
function x(e5) {
  return l$1 && y2 ? "Int32Array" === b(e5) : "[object Int32Array]" === m(e5);
}
function I(e5) {
  return l$1 && y2 ? "Float32Array" === b(e5) : "[object Float32Array]" === m(e5);
}
function M(e5) {
  return l$1 && y2 ? "Float64Array" === b(e5) : "[object Float64Array]" === m(e5);
}
function z(e5) {
  return l$1 && y2 ? "BigInt64Array" === b(e5) : "[object BigInt64Array]" === m(e5);
}
function F(e5) {
  return l$1 && y2 ? "BigUint64Array" === b(e5) : "[object BigUint64Array]" === m(e5);
}
function T(e5) {
  return "[object Map]" === m(e5);
}
function N(e5) {
  return "[object Set]" === m(e5);
}
function W(e5) {
  return "[object WeakMap]" === m(e5);
}
function $(e5) {
  return "[object WeakSet]" === m(e5);
}
function C(e5) {
  return "[object ArrayBuffer]" === m(e5);
}
function V(e5) {
  return "undefined" != typeof ArrayBuffer && (C.working ? C(e5) : e5 instanceof ArrayBuffer);
}
function G(e5) {
  return "[object DataView]" === m(e5);
}
function R(e5) {
  return "undefined" != typeof DataView && (G.working ? G(e5) : e5 instanceof DataView);
}
function J(e5) {
  return "[object SharedArrayBuffer]" === m(e5);
}
function _(e5) {
  return "undefined" != typeof SharedArrayBuffer && (J.working ? J(e5) : e5 instanceof SharedArrayBuffer);
}
function H(e5) {
  return O(e5, h2);
}
function Z(e5) {
  return O(e5, j);
}
function q(e5) {
  return O(e5, A);
}
function K(e5) {
  return s2 && O(e5, w);
}
function L(e5) {
  return p2 && O(e5, v2);
}
o$2.isArgumentsObject = f2, o$2.isGeneratorFunction = a2, o$2.isPromise = function(e5) {
  return "undefined" != typeof Promise && e5 instanceof Promise || null !== e5 && "object" == typeof e5 && "function" == typeof e5.then && "function" == typeof e5.catch;
}, o$2.isArrayBufferView = function(e5) {
  return d && ArrayBuffer.isView ? ArrayBuffer.isView(e5) : S(e5) || R(e5);
}, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T.working = "undefined" != typeof Map && T(/* @__PURE__ */ new Map()), o$2.isMap = function(e5) {
  return "undefined" != typeof Map && (T.working ? T(e5) : e5 instanceof Map);
}, N.working = "undefined" != typeof Set && N(/* @__PURE__ */ new Set()), o$2.isSet = function(e5) {
  return "undefined" != typeof Set && (N.working ? N(e5) : e5 instanceof Set);
}, W.working = "undefined" != typeof WeakMap && W(/* @__PURE__ */ new WeakMap()), o$2.isWeakMap = function(e5) {
  return "undefined" != typeof WeakMap && (W.working ? W(e5) : e5 instanceof WeakMap);
}, $.working = "undefined" != typeof WeakSet && $(/* @__PURE__ */ new WeakSet()), o$2.isWeakSet = function(e5) {
  return $(e5);
}, C.working = "undefined" != typeof ArrayBuffer && C(new ArrayBuffer()), o$2.isArrayBuffer = V, G.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = "undefined" != typeof SharedArrayBuffer && J(new SharedArrayBuffer()), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e5) {
  return "[object AsyncFunction]" === m(e5);
}, o$2.isMapIterator = function(e5) {
  return "[object Map Iterator]" === m(e5);
}, o$2.isSetIterator = function(e5) {
  return "[object Set Iterator]" === m(e5);
}, o$2.isGeneratorObject = function(e5) {
  return "[object Generator]" === m(e5);
}, o$2.isWebAssemblyCompiledModule = function(e5) {
  return "[object WebAssembly.Module]" === m(e5);
}, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(e5) {
  return H(e5) || Z(e5) || q(e5) || K(e5) || L(e5);
}, o$2.isAnyArrayBuffer = function(e5) {
  return l$1 && (V(e5) || _(e5));
}, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e5) {
  Object.defineProperty(o$2, e5, { enumerable: false, value: function() {
    throw new Error(e5 + " is not supported in userland");
  } });
});
var Q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis;
var X = {};
var Y = T$1;
var ee = Object.getOwnPropertyDescriptors || function(e5) {
  for (var t5 = Object.keys(e5), r5 = {}, n42 = 0; n42 < t5.length; n42++) r5[t5[n42]] = Object.getOwnPropertyDescriptor(e5, t5[n42]);
  return r5;
};
var te = /%[sdj%]/g;
X.format = function(e5) {
  if (!ge(e5)) {
    for (var t5 = [], r5 = 0; r5 < arguments.length; r5++) t5.push(oe(arguments[r5]));
    return t5.join(" ");
  }
  r5 = 1;
  for (var n42 = arguments, i42 = n42.length, o42 = String(e5).replace(te, function(e6) {
    if ("%%" === e6) return "%";
    if (r5 >= i42) return e6;
    switch (e6) {
      case "%s":
        return String(n42[r5++]);
      case "%d":
        return Number(n42[r5++]);
      case "%j":
        try {
          return JSON.stringify(n42[r5++]);
        } catch (e7) {
          return "[Circular]";
        }
      default:
        return e6;
    }
  }), u42 = n42[r5]; r5 < i42; u42 = n42[++r5]) le(u42) || !he(u42) ? o42 += " " + u42 : o42 += " " + oe(u42);
  return o42;
}, X.deprecate = function(e5, t5) {
  if (void 0 !== Y && true === Y.noDeprecation) return e5;
  if (void 0 === Y) return function() {
    return X.deprecate(e5, t5).apply(this || Q, arguments);
  };
  var r5 = false;
  return function() {
    if (!r5) {
      if (Y.throwDeprecation) throw new Error(t5);
      Y.traceDeprecation ? console.trace(t5) : console.error(t5), r5 = true;
    }
    return e5.apply(this || Q, arguments);
  };
};
var re = {};
var ne = /^$/;
if (Y.env.NODE_DEBUG) {
  ie = Y.env.NODE_DEBUG;
  ie = ie.replace(/[|\\\\{}()[\\]^$+?.]/g, "\\\\$&").replace(/\\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
}
var ie;
function oe(e5, t5) {
  var r5 = { seen: [], stylize: fe };
  return arguments.length >= 3 && (r5.depth = arguments[2]), arguments.length >= 4 && (r5.colors = arguments[3]), ye(t5) ? r5.showHidden = t5 : t5 && X._extend(r5, t5), be(r5.showHidden) && (r5.showHidden = false), be(r5.depth) && (r5.depth = 2), be(r5.colors) && (r5.colors = false), be(r5.customInspect) && (r5.customInspect = true), r5.colors && (r5.stylize = ue), ae(r5, e5, r5.depth);
}
function ue(e5, t5) {
  var r5 = oe.styles[t5];
  return r5 ? "\\x1B[" + oe.colors[r5][0] + "m" + e5 + "\\x1B[" + oe.colors[r5][1] + "m" : e5;
}
function fe(e5, t5) {
  return e5;
}
function ae(e5, t5, r5) {
  if (e5.customInspect && t5 && we(t5.inspect) && t5.inspect !== X.inspect && (!t5.constructor || t5.constructor.prototype !== t5)) {
    var n42 = t5.inspect(r5, e5);
    return ge(n42) || (n42 = ae(e5, n42, r5)), n42;
  }
  var i42 = function(e6, t6) {
    if (be(t6)) return e6.stylize("undefined", "undefined");
    if (ge(t6)) {
      var r6 = "'" + JSON.stringify(t6).replace(/^"|"$/g, "").replace(/'/g, "\\\\'").replace(/\\\\"/g, '"') + "'";
      return e6.stylize(r6, "string");
    }
    if (de(t6)) return e6.stylize("" + t6, "number");
    if (ye(t6)) return e6.stylize("" + t6, "boolean");
    if (le(t6)) return e6.stylize("null", "null");
  }(e5, t5);
  if (i42) return i42;
  var o42 = Object.keys(t5), u42 = function(e6) {
    var t6 = {};
    return e6.forEach(function(e7, r6) {
      t6[e7] = true;
    }), t6;
  }(o42);
  if (e5.showHidden && (o42 = Object.getOwnPropertyNames(t5)), Ae(t5) && (o42.indexOf("message") >= 0 || o42.indexOf("description") >= 0)) return ce(t5);
  if (0 === o42.length) {
    if (we(t5)) {
      var f42 = t5.name ? ": " + t5.name : "";
      return e5.stylize("[Function" + f42 + "]", "special");
    }
    if (me(t5)) return e5.stylize(RegExp.prototype.toString.call(t5), "regexp");
    if (je(t5)) return e5.stylize(Date.prototype.toString.call(t5), "date");
    if (Ae(t5)) return ce(t5);
  }
  var a42, c42 = "", s42 = false, p42 = ["{", "}"];
  (pe(t5) && (s42 = true, p42 = ["[", "]"]), we(t5)) && (c42 = " [Function" + (t5.name ? ": " + t5.name : "") + "]");
  return me(t5) && (c42 = " " + RegExp.prototype.toString.call(t5)), je(t5) && (c42 = " " + Date.prototype.toUTCString.call(t5)), Ae(t5) && (c42 = " " + ce(t5)), 0 !== o42.length || s42 && 0 != t5.length ? r5 < 0 ? me(t5) ? e5.stylize(RegExp.prototype.toString.call(t5), "regexp") : e5.stylize("[Object]", "special") : (e5.seen.push(t5), a42 = s42 ? function(e6, t6, r6, n5, i5) {
    for (var o5 = [], u5 = 0, f5 = t6.length; u5 < f5; ++u5) ke(t6, String(u5)) ? o5.push(se(e6, t6, r6, n5, String(u5), true)) : o5.push("");
    return i5.forEach(function(i6) {
      i6.match(/^\\d+$/) || o5.push(se(e6, t6, r6, n5, i6, true));
    }), o5;
  }(e5, t5, r5, u42, o42) : o42.map(function(n5) {
    return se(e5, t5, r5, u42, n5, s42);
  }), e5.seen.pop(), function(e6, t6, r6) {
    var n5 = 0;
    if (e6.reduce(function(e7, t7) {
      return n5++, t7.indexOf("\\n") >= 0 && n5++, e7 + t7.replace(/\\u001b\\[\\d\\d?m/g, "").length + 1;
    }, 0) > 60) return r6[0] + ("" === t6 ? "" : t6 + "\\n ") + " " + e6.join(",\\n  ") + " " + r6[1];
    return r6[0] + t6 + " " + e6.join(", ") + " " + r6[1];
  }(a42, c42, p42)) : p42[0] + c42 + p42[1];
}
function ce(e5) {
  return "[" + Error.prototype.toString.call(e5) + "]";
}
function se(e5, t5, r5, n42, i42, o42) {
  var u42, f42, a42;
  if ((a42 = Object.getOwnPropertyDescriptor(t5, i42) || { value: t5[i42] }).get ? f42 = a42.set ? e5.stylize("[Getter/Setter]", "special") : e5.stylize("[Getter]", "special") : a42.set && (f42 = e5.stylize("[Setter]", "special")), ke(n42, i42) || (u42 = "[" + i42 + "]"), f42 || (e5.seen.indexOf(a42.value) < 0 ? (f42 = le(r5) ? ae(e5, a42.value, null) : ae(e5, a42.value, r5 - 1)).indexOf("\\n") > -1 && (f42 = o42 ? f42.split("\\n").map(function(e6) {
    return "  " + e6;
  }).join("\\n").substr(2) : "\\n" + f42.split("\\n").map(function(e6) {
    return "   " + e6;
  }).join("\\n")) : f42 = e5.stylize("[Circular]", "special")), be(u42)) {
    if (o42 && i42.match(/^\\d+$/)) return f42;
    (u42 = JSON.stringify("" + i42)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u42 = u42.substr(1, u42.length - 2), u42 = e5.stylize(u42, "name")) : (u42 = u42.replace(/'/g, "\\\\'").replace(/\\\\"/g, '"').replace(/(^"|"$)/g, "'"), u42 = e5.stylize(u42, "string"));
  }
  return u42 + ": " + f42;
}
function pe(e5) {
  return Array.isArray(e5);
}
function ye(e5) {
  return "boolean" == typeof e5;
}
function le(e5) {
  return null === e5;
}
function de(e5) {
  return "number" == typeof e5;
}
function ge(e5) {
  return "string" == typeof e5;
}
function be(e5) {
  return void 0 === e5;
}
function me(e5) {
  return he(e5) && "[object RegExp]" === ve(e5);
}
function he(e5) {
  return "object" == typeof e5 && null !== e5;
}
function je(e5) {
  return he(e5) && "[object Date]" === ve(e5);
}
function Ae(e5) {
  return he(e5) && ("[object Error]" === ve(e5) || e5 instanceof Error);
}
function we(e5) {
  return "function" == typeof e5;
}
function ve(e5) {
  return Object.prototype.toString.call(e5);
}
function Oe(e5) {
  return e5 < 10 ? "0" + e5.toString(10) : e5.toString(10);
}
X.debuglog = function(e5) {
  if (e5 = e5.toUpperCase(), !re[e5]) if (ne.test(e5)) {
    var t5 = Y.pid;
    re[e5] = function() {
      var r5 = X.format.apply(X, arguments);
      console.error("%s %d: %s", e5, t5, r5);
    };
  } else re[e5] = function() {
  };
  return re[e5];
}, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e5) {
  return null == e5;
}, X.isNumber = de, X.isString = ge, X.isSymbol = function(e5) {
  return "symbol" == typeof e5;
}, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e5) {
  return null === e5 || "boolean" == typeof e5 || "number" == typeof e5 || "string" == typeof e5 || "symbol" == typeof e5 || void 0 === e5;
}, X.isBuffer = i$1;
var Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function Be() {
  var e5 = /* @__PURE__ */ new Date(), t5 = [Oe(e5.getHours()), Oe(e5.getMinutes()), Oe(e5.getSeconds())].join(":");
  return [e5.getDate(), Se[e5.getMonth()], t5].join(" ");
}
function ke(e5, t5) {
  return Object.prototype.hasOwnProperty.call(e5, t5);
}
X.log = function() {
  console.log("%s - %s", Be(), X.format.apply(X, arguments));
}, X.inherits = t$2, X._extend = function(e5, t5) {
  if (!t5 || !he(t5)) return e5;
  for (var r5 = Object.keys(t5), n42 = r5.length; n42--; ) e5[r5[n42]] = t5[r5[n42]];
  return e5;
};
var Ee = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
function De(e5, t5) {
  if (!e5) {
    var r5 = new Error("Promise was rejected with a falsy value");
    r5.reason = e5, e5 = r5;
  }
  return t5(e5);
}
X.promisify = function(e5) {
  if ("function" != typeof e5) throw new TypeError('The "original" argument must be of type Function');
  if (Ee && e5[Ee]) {
    var t5;
    if ("function" != typeof (t5 = e5[Ee])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(t5, Ee, { value: t5, enumerable: false, writable: false, configurable: true }), t5;
  }
  function t5() {
    for (var t6, r5, n42 = new Promise(function(e6, n5) {
      t6 = e6, r5 = n5;
    }), i42 = [], o42 = 0; o42 < arguments.length; o42++) i42.push(arguments[o42]);
    i42.push(function(e6, n5) {
      e6 ? r5(e6) : t6(n5);
    });
    try {
      e5.apply(this || Q, i42);
    } catch (e6) {
      r5(e6);
    }
    return n42;
  }
  return Object.setPrototypeOf(t5, Object.getPrototypeOf(e5)), Ee && Object.defineProperty(t5, Ee, { value: t5, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t5, ee(e5));
}, X.promisify.custom = Ee, X.callbackify = function(e5) {
  if ("function" != typeof e5) throw new TypeError('The "original" argument must be of type Function');
  function t5() {
    for (var t6 = [], r5 = 0; r5 < arguments.length; r5++) t6.push(arguments[r5]);
    var n42 = t6.pop();
    if ("function" != typeof n42) throw new TypeError("The last argument must be of type Function");
    var i42 = this || Q, o42 = function() {
      return n42.apply(i42, arguments);
    };
    e5.apply(this || Q, t6).then(function(e6) {
      Y.nextTick(o42.bind(null, null, e6));
    }, function(e6) {
      Y.nextTick(De.bind(null, e6, o42));
    });
  }
  return Object.setPrototypeOf(t5, Object.getPrototypeOf(e5)), Object.defineProperties(t5, ee(e5)), t5;
};
X._extend;
X.callbackify;
X.debuglog;
X.deprecate;
X.format;
X.inherits;
X.inspect;
X.isArray;
X.isBoolean;
X.isBuffer;
X.isDate;
X.isError;
X.isFunction;
X.isNull;
X.isNullOrUndefined;
X.isNumber;
X.isObject;
X.isPrimitive;
X.isRegExp;
X.isString;
X.isSymbol;
X.isUndefined;
X.log;
X.promisify;
X._extend;
X.callbackify;
X.debuglog;
X.deprecate;
X.format;
X.inherits;
X.inspect;
X.isArray;
X.isBoolean;
X.isBuffer;
X.isDate;
X.isError;
X.isFunction;
X.isNull;
X.isNullOrUndefined;
X.isNumber;
X.isObject;
X.isPrimitive;
X.isRegExp;
X.isString;
X.isSymbol;
X.isUndefined;
X.log;
var promisify = X.promisify;
X.types;
var exports2 = {};
var _dewExec2 = false;
var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
function dew2() {
  if (_dewExec2) return exports2;
  _dewExec2 = true;
  var process3 = exports2 = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e5) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e5) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e5) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e6) {
        return cachedSetTimeout.call(this || _global, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e5) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e6) {
        return cachedClearTimeout.call(this || _global, marker);
      }
    }
  }
  var queue2 = [];
  var draining2 = false;
  var currentQueue2;
  var queueIndex2 = -1;
  function cleanUpNextTick2() {
    if (!draining2 || !currentQueue2) {
      return;
    }
    draining2 = false;
    if (currentQueue2.length) {
      queue2 = currentQueue2.concat(queue2);
    } else {
      queueIndex2 = -1;
    }
    if (queue2.length) {
      drainQueue2();
    }
  }
  function drainQueue2() {
    if (draining2) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick2);
    draining2 = true;
    var len = queue2.length;
    while (len) {
      currentQueue2 = queue2;
      queue2 = [];
      while (++queueIndex2 < len) {
        if (currentQueue2) {
          currentQueue2[queueIndex2].run();
        }
      }
      queueIndex2 = -1;
      len = queue2.length;
    }
    currentQueue2 = null;
    draining2 = false;
    runClearTimeout(timeout);
  }
  process3.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i42 = 1; i42 < arguments.length; i42++) {
        args[i42 - 1] = arguments[i42];
      }
    }
    queue2.push(new Item2(fun, args));
    if (queue2.length === 1 && !draining2) {
      runTimeout(drainQueue2);
    }
  };
  function Item2(fun, array) {
    (this || _global).fun = fun;
    (this || _global).array = array;
  }
  Item2.prototype.run = function() {
    (this || _global).fun.apply(null, (this || _global).array);
  };
  process3.title = "browser";
  process3.browser = true;
  process3.env = {};
  process3.argv = [];
  process3.version = "";
  process3.versions = {};
  function noop2() {
  }
  process3.on = noop2;
  process3.addListener = noop2;
  process3.once = noop2;
  process3.off = noop2;
  process3.removeListener = noop2;
  process3.removeAllListeners = noop2;
  process3.emit = noop2;
  process3.prependListener = noop2;
  process3.prependOnceListener = noop2;
  process3.listeners = function(name2) {
    return [];
  };
  process3.binding = function(name2) {
    throw new Error("process.binding is not supported");
  };
  process3.cwd = function() {
    return "/";
  };
  process3.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process3.umask = function() {
    return 0;
  };
  return exports2;
}
var process = dew2();
process.platform = "browser";
process.addListener;
process.argv;
process.binding;
process.browser;
process.chdir;
process.cwd;
process.emit;
process.env;
process.listeners;
process.nextTick;
process.off;
process.on;
process.once;
process.prependListener;
process.prependOnceListener;
process.removeAllListeners;
process.removeListener;
process.title;
process.umask;
process.version;
process.versions;
for (r$13 = { byteLength: function(r5) {
  var t5 = u$22(r5), e5 = t5[0], n42 = t5[1];
  return 3 * (e5 + n42) / 4 - n42;
}, toByteArray: function(r5) {
  var t5, o42, a42 = u$22(r5), h5 = a42[0], c42 = a42[1], d4 = new n$23(function(r6, t6, e5) {
    return 3 * (t6 + e5) / 4 - e5;
  }(0, h5, c42)), f42 = 0, A4 = c42 > 0 ? h5 - 4 : h5;
  for (o42 = 0; o42 < A4; o42 += 4) t5 = e$23[r5.charCodeAt(o42)] << 18 | e$23[r5.charCodeAt(o42 + 1)] << 12 | e$23[r5.charCodeAt(o42 + 2)] << 6 | e$23[r5.charCodeAt(o42 + 3)], d4[f42++] = t5 >> 16 & 255, d4[f42++] = t5 >> 8 & 255, d4[f42++] = 255 & t5;
  2 === c42 && (t5 = e$23[r5.charCodeAt(o42)] << 2 | e$23[r5.charCodeAt(o42 + 1)] >> 4, d4[f42++] = 255 & t5);
  1 === c42 && (t5 = e$23[r5.charCodeAt(o42)] << 10 | e$23[r5.charCodeAt(o42 + 1)] << 4 | e$23[r5.charCodeAt(o42 + 2)] >> 2, d4[f42++] = t5 >> 8 & 255, d4[f42++] = 255 & t5);
  return d4;
}, fromByteArray: function(r5) {
  for (var e5, n42 = r5.length, o42 = n42 % 3, a42 = [], h5 = 0, u42 = n42 - o42; h5 < u42; h5 += 16383) a42.push(c$12(r5, h5, h5 + 16383 > u42 ? u42 : h5 + 16383));
  1 === o42 ? (e5 = r5[n42 - 1], a42.push(t$13[e5 >> 2] + t$13[e5 << 4 & 63] + "==")) : 2 === o42 && (e5 = (r5[n42 - 2] << 8) + r5[n42 - 1], a42.push(t$13[e5 >> 10] + t$13[e5 >> 4 & 63] + t$13[e5 << 2 & 63] + "="));
  return a42.join("");
} }, t$13 = [], e$23 = [], n$23 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o$23 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a$13 = 0, h$13 = o$23.length; a$13 < h$13; ++a$13) t$13[a$13] = o$23[a$13], e$23[o$23.charCodeAt(a$13)] = a$13;
var r$13;
var t$13;
var e$23;
var n$23;
var o$23;
var a$13;
var h$13;
function u$22(r5) {
  var t5 = r5.length;
  if (t5 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
  var e5 = r5.indexOf("=");
  return -1 === e5 && (e5 = t5), [e5, e5 === t5 ? 0 : 4 - e5 % 4];
}
function c$12(r5, e5, n42) {
  for (var o42, a42, h5 = [], u42 = e5; u42 < n42; u42 += 3) o42 = (r5[u42] << 16 & 16711680) + (r5[u42 + 1] << 8 & 65280) + (255 & r5[u42 + 2]), h5.push(t$13[(a42 = o42) >> 18 & 63] + t$13[a42 >> 12 & 63] + t$13[a42 >> 6 & 63] + t$13[63 & a42]);
  return h5.join("");
}
e$23["-".charCodeAt(0)] = 62, e$23["_".charCodeAt(0)] = 63;
var a$1$1 = { read: function(a42, t5, o42, r5, h5) {
  var M4, f42, p42 = 8 * h5 - r5 - 1, w4 = (1 << p42) - 1, e5 = w4 >> 1, i42 = -7, N4 = o42 ? h5 - 1 : 0, n42 = o42 ? -1 : 1, u42 = a42[t5 + N4];
  for (N4 += n42, M4 = u42 & (1 << -i42) - 1, u42 >>= -i42, i42 += p42; i42 > 0; M4 = 256 * M4 + a42[t5 + N4], N4 += n42, i42 -= 8) ;
  for (f42 = M4 & (1 << -i42) - 1, M4 >>= -i42, i42 += r5; i42 > 0; f42 = 256 * f42 + a42[t5 + N4], N4 += n42, i42 -= 8) ;
  if (0 === M4) M4 = 1 - e5;
  else {
    if (M4 === w4) return f42 ? NaN : 1 / 0 * (u42 ? -1 : 1);
    f42 += Math.pow(2, r5), M4 -= e5;
  }
  return (u42 ? -1 : 1) * f42 * Math.pow(2, M4 - r5);
}, write: function(a42, t5, o42, r5, h5, M4) {
  var f42, p42, w4, e5 = 8 * M4 - h5 - 1, i42 = (1 << e5) - 1, N4 = i42 >> 1, n42 = 23 === h5 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u42 = r5 ? 0 : M4 - 1, l42 = r5 ? 1 : -1, s42 = t5 < 0 || 0 === t5 && 1 / t5 < 0 ? 1 : 0;
  for (t5 = Math.abs(t5), isNaN(t5) || t5 === 1 / 0 ? (p42 = isNaN(t5) ? 1 : 0, f42 = i42) : (f42 = Math.floor(Math.log(t5) / Math.LN2), t5 * (w4 = Math.pow(2, -f42)) < 1 && (f42--, w4 *= 2), (t5 += f42 + N4 >= 1 ? n42 / w4 : n42 * Math.pow(2, 1 - N4)) * w4 >= 2 && (f42++, w4 /= 2), f42 + N4 >= i42 ? (p42 = 0, f42 = i42) : f42 + N4 >= 1 ? (p42 = (t5 * w4 - 1) * Math.pow(2, h5), f42 += N4) : (p42 = t5 * Math.pow(2, N4 - 1) * Math.pow(2, h5), f42 = 0)); h5 >= 8; a42[o42 + u42] = 255 & p42, u42 += l42, p42 /= 256, h5 -= 8) ;
  for (f42 = f42 << h5 | p42, e5 += h5; e5 > 0; a42[o42 + u42] = 255 & f42, u42 += l42, f42 /= 256, e5 -= 8) ;
  a42[o42 + u42 - l42] |= 128 * s42;
} };
var e$1$1 = {};
var n$1$1 = r$13;
var i$12 = a$1$1;
var o$1$1 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
e$1$1.Buffer = u$1$1, e$1$1.SlowBuffer = function(t5) {
  +t5 != t5 && (t5 = 0);
  return u$1$1.alloc(+t5);
}, e$1$1.INSPECT_MAX_BYTES = 50;
function f$2(t5) {
  if (t5 > 2147483647) throw new RangeError('The value "' + t5 + '" is invalid for option "size"');
  var r5 = new Uint8Array(t5);
  return Object.setPrototypeOf(r5, u$1$1.prototype), r5;
}
function u$1$1(t5, r5, e5) {
  if ("number" == typeof t5) {
    if ("string" == typeof r5) throw new TypeError('The "string" argument must be of type string. Received type number');
    return a$2(t5);
  }
  return s$12(t5, r5, e5);
}
function s$12(t5, r5, e5) {
  if ("string" == typeof t5) return function(t6, r6) {
    "string" == typeof r6 && "" !== r6 || (r6 = "utf8");
    if (!u$1$1.isEncoding(r6)) throw new TypeError("Unknown encoding: " + r6);
    var e6 = 0 | y3(t6, r6), n5 = f$2(e6), i5 = n5.write(t6, r6);
    i5 !== e6 && (n5 = n5.slice(0, i5));
    return n5;
  }(t5, r5);
  if (ArrayBuffer.isView(t5)) return p3(t5);
  if (null == t5) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t5);
  if (F2(t5, ArrayBuffer) || t5 && F2(t5.buffer, ArrayBuffer)) return c$1$1(t5, r5, e5);
  if ("undefined" != typeof SharedArrayBuffer && (F2(t5, SharedArrayBuffer) || t5 && F2(t5.buffer, SharedArrayBuffer))) return c$1$1(t5, r5, e5);
  if ("number" == typeof t5) throw new TypeError('The "value" argument must not be of type number. Received type number');
  var n42 = t5.valueOf && t5.valueOf();
  if (null != n42 && n42 !== t5) return u$1$1.from(n42, r5, e5);
  var i42 = function(t6) {
    if (u$1$1.isBuffer(t6)) {
      var r6 = 0 | l$12(t6.length), e6 = f$2(r6);
      return 0 === e6.length || t6.copy(e6, 0, 0, r6), e6;
    }
    if (void 0 !== t6.length) return "number" != typeof t6.length || N2(t6.length) ? f$2(0) : p3(t6);
    if ("Buffer" === t6.type && Array.isArray(t6.data)) return p3(t6.data);
  }(t5);
  if (i42) return i42;
  if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t5[Symbol.toPrimitive]) return u$1$1.from(t5[Symbol.toPrimitive]("string"), r5, e5);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t5);
}
function h$1$1(t5) {
  if ("number" != typeof t5) throw new TypeError('"size" argument must be of type number');
  if (t5 < 0) throw new RangeError('The value "' + t5 + '" is invalid for option "size"');
}
function a$2(t5) {
  return h$1$1(t5), f$2(t5 < 0 ? 0 : 0 | l$12(t5));
}
function p3(t5) {
  for (var r5 = t5.length < 0 ? 0 : 0 | l$12(t5.length), e5 = f$2(r5), n42 = 0; n42 < r5; n42 += 1) e5[n42] = 255 & t5[n42];
  return e5;
}
function c$1$1(t5, r5, e5) {
  if (r5 < 0 || t5.byteLength < r5) throw new RangeError('"offset" is outside of buffer bounds');
  if (t5.byteLength < r5 + (e5 || 0)) throw new RangeError('"length" is outside of buffer bounds');
  var n42;
  return n42 = void 0 === r5 && void 0 === e5 ? new Uint8Array(t5) : void 0 === e5 ? new Uint8Array(t5, r5) : new Uint8Array(t5, r5, e5), Object.setPrototypeOf(n42, u$1$1.prototype), n42;
}
function l$12(t5) {
  if (t5 >= 2147483647) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
  return 0 | t5;
}
function y3(t5, r5) {
  if (u$1$1.isBuffer(t5)) return t5.length;
  if (ArrayBuffer.isView(t5) || F2(t5, ArrayBuffer)) return t5.byteLength;
  if ("string" != typeof t5) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t5);
  var e5 = t5.length, n42 = arguments.length > 2 && true === arguments[2];
  if (!n42 && 0 === e5) return 0;
  for (var i42 = false; ; ) switch (r5) {
    case "ascii":
    case "latin1":
    case "binary":
      return e5;
    case "utf8":
    case "utf-8":
      return _2(t5).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * e5;
    case "hex":
      return e5 >>> 1;
    case "base64":
      return z2(t5).length;
    default:
      if (i42) return n42 ? -1 : _2(t5).length;
      r5 = ("" + r5).toLowerCase(), i42 = true;
  }
}
function g2(t5, r5, e5) {
  var n42 = false;
  if ((void 0 === r5 || r5 < 0) && (r5 = 0), r5 > this.length) return "";
  if ((void 0 === e5 || e5 > this.length) && (e5 = this.length), e5 <= 0) return "";
  if ((e5 >>>= 0) <= (r5 >>>= 0)) return "";
  for (t5 || (t5 = "utf8"); ; ) switch (t5) {
    case "hex":
      return O2(this, r5, e5);
    case "utf8":
    case "utf-8":
      return I2(this, r5, e5);
    case "ascii":
      return S2(this, r5, e5);
    case "latin1":
    case "binary":
      return R2(this, r5, e5);
    case "base64":
      return T2(this, r5, e5);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return L2(this, r5, e5);
    default:
      if (n42) throw new TypeError("Unknown encoding: " + t5);
      t5 = (t5 + "").toLowerCase(), n42 = true;
  }
}
function w2(t5, r5, e5) {
  var n42 = t5[r5];
  t5[r5] = t5[e5], t5[e5] = n42;
}
function d2(t5, r5, e5, n42, i42) {
  if (0 === t5.length) return -1;
  if ("string" == typeof e5 ? (n42 = e5, e5 = 0) : e5 > 2147483647 ? e5 = 2147483647 : e5 < -2147483648 && (e5 = -2147483648), N2(e5 = +e5) && (e5 = i42 ? 0 : t5.length - 1), e5 < 0 && (e5 = t5.length + e5), e5 >= t5.length) {
    if (i42) return -1;
    e5 = t5.length - 1;
  } else if (e5 < 0) {
    if (!i42) return -1;
    e5 = 0;
  }
  if ("string" == typeof r5 && (r5 = u$1$1.from(r5, n42)), u$1$1.isBuffer(r5)) return 0 === r5.length ? -1 : v3(t5, r5, e5, n42, i42);
  if ("number" == typeof r5) return r5 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i42 ? Uint8Array.prototype.indexOf.call(t5, r5, e5) : Uint8Array.prototype.lastIndexOf.call(t5, r5, e5) : v3(t5, [r5], e5, n42, i42);
  throw new TypeError("val must be string, number or Buffer");
}
function v3(t5, r5, e5, n42, i42) {
  var o42, f42 = 1, u42 = t5.length, s42 = r5.length;
  if (void 0 !== n42 && ("ucs2" === (n42 = String(n42).toLowerCase()) || "ucs-2" === n42 || "utf16le" === n42 || "utf-16le" === n42)) {
    if (t5.length < 2 || r5.length < 2) return -1;
    f42 = 2, u42 /= 2, s42 /= 2, e5 /= 2;
  }
  function h5(t6, r6) {
    return 1 === f42 ? t6[r6] : t6.readUInt16BE(r6 * f42);
  }
  if (i42) {
    var a42 = -1;
    for (o42 = e5; o42 < u42; o42++) if (h5(t5, o42) === h5(r5, -1 === a42 ? 0 : o42 - a42)) {
      if (-1 === a42 && (a42 = o42), o42 - a42 + 1 === s42) return a42 * f42;
    } else -1 !== a42 && (o42 -= o42 - a42), a42 = -1;
  } else for (e5 + s42 > u42 && (e5 = u42 - s42), o42 = e5; o42 >= 0; o42--) {
    for (var p42 = true, c42 = 0; c42 < s42; c42++) if (h5(t5, o42 + c42) !== h5(r5, c42)) {
      p42 = false;
      break;
    }
    if (p42) return o42;
  }
  return -1;
}
function b2(t5, r5, e5, n42) {
  e5 = Number(e5) || 0;
  var i42 = t5.length - e5;
  n42 ? (n42 = Number(n42)) > i42 && (n42 = i42) : n42 = i42;
  var o42 = r5.length;
  n42 > o42 / 2 && (n42 = o42 / 2);
  for (var f42 = 0; f42 < n42; ++f42) {
    var u42 = parseInt(r5.substr(2 * f42, 2), 16);
    if (N2(u42)) return f42;
    t5[e5 + f42] = u42;
  }
  return f42;
}
function m2(t5, r5, e5, n42) {
  return D2(_2(r5, t5.length - e5), t5, e5, n42);
}
function E2(t5, r5, e5, n42) {
  return D2(function(t6) {
    for (var r6 = [], e6 = 0; e6 < t6.length; ++e6) r6.push(255 & t6.charCodeAt(e6));
    return r6;
  }(r5), t5, e5, n42);
}
function B2(t5, r5, e5, n42) {
  return E2(t5, r5, e5, n42);
}
function A2(t5, r5, e5, n42) {
  return D2(z2(r5), t5, e5, n42);
}
function U2(t5, r5, e5, n42) {
  return D2(function(t6, r6) {
    for (var e6, n5, i42, o42 = [], f42 = 0; f42 < t6.length && !((r6 -= 2) < 0); ++f42) e6 = t6.charCodeAt(f42), n5 = e6 >> 8, i42 = e6 % 256, o42.push(i42), o42.push(n5);
    return o42;
  }(r5, t5.length - e5), t5, e5, n42);
}
function T2(t5, r5, e5) {
  return 0 === r5 && e5 === t5.length ? n$1$1.fromByteArray(t5) : n$1$1.fromByteArray(t5.slice(r5, e5));
}
function I2(t5, r5, e5) {
  e5 = Math.min(t5.length, e5);
  for (var n42 = [], i42 = r5; i42 < e5; ) {
    var o42, f42, u42, s42, h5 = t5[i42], a42 = null, p42 = h5 > 239 ? 4 : h5 > 223 ? 3 : h5 > 191 ? 2 : 1;
    if (i42 + p42 <= e5) switch (p42) {
      case 1:
        h5 < 128 && (a42 = h5);
        break;
      case 2:
        128 == (192 & (o42 = t5[i42 + 1])) && (s42 = (31 & h5) << 6 | 63 & o42) > 127 && (a42 = s42);
        break;
      case 3:
        o42 = t5[i42 + 1], f42 = t5[i42 + 2], 128 == (192 & o42) && 128 == (192 & f42) && (s42 = (15 & h5) << 12 | (63 & o42) << 6 | 63 & f42) > 2047 && (s42 < 55296 || s42 > 57343) && (a42 = s42);
        break;
      case 4:
        o42 = t5[i42 + 1], f42 = t5[i42 + 2], u42 = t5[i42 + 3], 128 == (192 & o42) && 128 == (192 & f42) && 128 == (192 & u42) && (s42 = (15 & h5) << 18 | (63 & o42) << 12 | (63 & f42) << 6 | 63 & u42) > 65535 && s42 < 1114112 && (a42 = s42);
    }
    null === a42 ? (a42 = 65533, p42 = 1) : a42 > 65535 && (a42 -= 65536, n42.push(a42 >>> 10 & 1023 | 55296), a42 = 56320 | 1023 & a42), n42.push(a42), i42 += p42;
  }
  return function(t6) {
    var r6 = t6.length;
    if (r6 <= 4096) return String.fromCharCode.apply(String, t6);
    var e6 = "", n5 = 0;
    for (; n5 < r6; ) e6 += String.fromCharCode.apply(String, t6.slice(n5, n5 += 4096));
    return e6;
  }(n42);
}
e$1$1.kMaxLength = 2147483647, u$1$1.TYPED_ARRAY_SUPPORT = function() {
  try {
    var t5 = new Uint8Array(1), r5 = { foo: function() {
      return 42;
    } };
    return Object.setPrototypeOf(r5, Uint8Array.prototype), Object.setPrototypeOf(t5, r5), 42 === t5.foo();
  } catch (t6) {
    return false;
  }
}(), u$1$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by \`buffer\` v5.x. Use \`buffer\` v4.x if you require old browser support."), Object.defineProperty(u$1$1.prototype, "parent", { enumerable: true, get: function() {
  if (u$1$1.isBuffer(this)) return this.buffer;
} }), Object.defineProperty(u$1$1.prototype, "offset", { enumerable: true, get: function() {
  if (u$1$1.isBuffer(this)) return this.byteOffset;
} }), u$1$1.poolSize = 8192, u$1$1.from = function(t5, r5, e5) {
  return s$12(t5, r5, e5);
}, Object.setPrototypeOf(u$1$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$1, Uint8Array), u$1$1.alloc = function(t5, r5, e5) {
  return function(t6, r6, e6) {
    return h$1$1(t6), t6 <= 0 ? f$2(t6) : void 0 !== r6 ? "string" == typeof e6 ? f$2(t6).fill(r6, e6) : f$2(t6).fill(r6) : f$2(t6);
  }(t5, r5, e5);
}, u$1$1.allocUnsafe = function(t5) {
  return a$2(t5);
}, u$1$1.allocUnsafeSlow = function(t5) {
  return a$2(t5);
}, u$1$1.isBuffer = function(t5) {
  return null != t5 && true === t5._isBuffer && t5 !== u$1$1.prototype;
}, u$1$1.compare = function(t5, r5) {
  if (F2(t5, Uint8Array) && (t5 = u$1$1.from(t5, t5.offset, t5.byteLength)), F2(r5, Uint8Array) && (r5 = u$1$1.from(r5, r5.offset, r5.byteLength)), !u$1$1.isBuffer(t5) || !u$1$1.isBuffer(r5)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  if (t5 === r5) return 0;
  for (var e5 = t5.length, n42 = r5.length, i42 = 0, o42 = Math.min(e5, n42); i42 < o42; ++i42) if (t5[i42] !== r5[i42]) {
    e5 = t5[i42], n42 = r5[i42];
    break;
  }
  return e5 < n42 ? -1 : n42 < e5 ? 1 : 0;
}, u$1$1.isEncoding = function(t5) {
  switch (String(t5).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, u$1$1.concat = function(t5, r5) {
  if (!Array.isArray(t5)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (0 === t5.length) return u$1$1.alloc(0);
  var e5;
  if (void 0 === r5) for (r5 = 0, e5 = 0; e5 < t5.length; ++e5) r5 += t5[e5].length;
  var n42 = u$1$1.allocUnsafe(r5), i42 = 0;
  for (e5 = 0; e5 < t5.length; ++e5) {
    var o42 = t5[e5];
    if (F2(o42, Uint8Array) && (o42 = u$1$1.from(o42)), !u$1$1.isBuffer(o42)) throw new TypeError('"list" argument must be an Array of Buffers');
    o42.copy(n42, i42), i42 += o42.length;
  }
  return n42;
}, u$1$1.byteLength = y3, u$1$1.prototype._isBuffer = true, u$1$1.prototype.swap16 = function() {
  var t5 = this.length;
  if (t5 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var r5 = 0; r5 < t5; r5 += 2) w2(this, r5, r5 + 1);
  return this;
}, u$1$1.prototype.swap32 = function() {
  var t5 = this.length;
  if (t5 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var r5 = 0; r5 < t5; r5 += 4) w2(this, r5, r5 + 3), w2(this, r5 + 1, r5 + 2);
  return this;
}, u$1$1.prototype.swap64 = function() {
  var t5 = this.length;
  if (t5 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var r5 = 0; r5 < t5; r5 += 8) w2(this, r5, r5 + 7), w2(this, r5 + 1, r5 + 6), w2(this, r5 + 2, r5 + 5), w2(this, r5 + 3, r5 + 4);
  return this;
}, u$1$1.prototype.toString = function() {
  var t5 = this.length;
  return 0 === t5 ? "" : 0 === arguments.length ? I2(this, 0, t5) : g2.apply(this, arguments);
}, u$1$1.prototype.toLocaleString = u$1$1.prototype.toString, u$1$1.prototype.equals = function(t5) {
  if (!u$1$1.isBuffer(t5)) throw new TypeError("Argument must be a Buffer");
  return this === t5 || 0 === u$1$1.compare(this, t5);
}, u$1$1.prototype.inspect = function() {
  var t5 = "", r5 = e$1$1.INSPECT_MAX_BYTES;
  return t5 = this.toString("hex", 0, r5).replace(/(.{2})/g, "$1 ").trim(), this.length > r5 && (t5 += " ... "), "<Buffer " + t5 + ">";
}, o$1$1 && (u$1$1.prototype[o$1$1] = u$1$1.prototype.inspect), u$1$1.prototype.compare = function(t5, r5, e5, n42, i42) {
  if (F2(t5, Uint8Array) && (t5 = u$1$1.from(t5, t5.offset, t5.byteLength)), !u$1$1.isBuffer(t5)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t5);
  if (void 0 === r5 && (r5 = 0), void 0 === e5 && (e5 = t5 ? t5.length : 0), void 0 === n42 && (n42 = 0), void 0 === i42 && (i42 = this.length), r5 < 0 || e5 > t5.length || n42 < 0 || i42 > this.length) throw new RangeError("out of range index");
  if (n42 >= i42 && r5 >= e5) return 0;
  if (n42 >= i42) return -1;
  if (r5 >= e5) return 1;
  if (this === t5) return 0;
  for (var o42 = (i42 >>>= 0) - (n42 >>>= 0), f42 = (e5 >>>= 0) - (r5 >>>= 0), s42 = Math.min(o42, f42), h5 = this.slice(n42, i42), a42 = t5.slice(r5, e5), p42 = 0; p42 < s42; ++p42) if (h5[p42] !== a42[p42]) {
    o42 = h5[p42], f42 = a42[p42];
    break;
  }
  return o42 < f42 ? -1 : f42 < o42 ? 1 : 0;
}, u$1$1.prototype.includes = function(t5, r5, e5) {
  return -1 !== this.indexOf(t5, r5, e5);
}, u$1$1.prototype.indexOf = function(t5, r5, e5) {
  return d2(this, t5, r5, e5, true);
}, u$1$1.prototype.lastIndexOf = function(t5, r5, e5) {
  return d2(this, t5, r5, e5, false);
}, u$1$1.prototype.write = function(t5, r5, e5, n42) {
  if (void 0 === r5) n42 = "utf8", e5 = this.length, r5 = 0;
  else if (void 0 === e5 && "string" == typeof r5) n42 = r5, e5 = this.length, r5 = 0;
  else {
    if (!isFinite(r5)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    r5 >>>= 0, isFinite(e5) ? (e5 >>>= 0, void 0 === n42 && (n42 = "utf8")) : (n42 = e5, e5 = void 0);
  }
  var i42 = this.length - r5;
  if ((void 0 === e5 || e5 > i42) && (e5 = i42), t5.length > 0 && (e5 < 0 || r5 < 0) || r5 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  n42 || (n42 = "utf8");
  for (var o42 = false; ; ) switch (n42) {
    case "hex":
      return b2(this, t5, r5, e5);
    case "utf8":
    case "utf-8":
      return m2(this, t5, r5, e5);
    case "ascii":
      return E2(this, t5, r5, e5);
    case "latin1":
    case "binary":
      return B2(this, t5, r5, e5);
    case "base64":
      return A2(this, t5, r5, e5);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return U2(this, t5, r5, e5);
    default:
      if (o42) throw new TypeError("Unknown encoding: " + n42);
      n42 = ("" + n42).toLowerCase(), o42 = true;
  }
}, u$1$1.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
function S2(t5, r5, e5) {
  var n42 = "";
  e5 = Math.min(t5.length, e5);
  for (var i42 = r5; i42 < e5; ++i42) n42 += String.fromCharCode(127 & t5[i42]);
  return n42;
}
function R2(t5, r5, e5) {
  var n42 = "";
  e5 = Math.min(t5.length, e5);
  for (var i42 = r5; i42 < e5; ++i42) n42 += String.fromCharCode(t5[i42]);
  return n42;
}
function O2(t5, r5, e5) {
  var n42 = t5.length;
  (!r5 || r5 < 0) && (r5 = 0), (!e5 || e5 < 0 || e5 > n42) && (e5 = n42);
  for (var i42 = "", o42 = r5; o42 < e5; ++o42) i42 += Y2[t5[o42]];
  return i42;
}
function L2(t5, r5, e5) {
  for (var n42 = t5.slice(r5, e5), i42 = "", o42 = 0; o42 < n42.length; o42 += 2) i42 += String.fromCharCode(n42[o42] + 256 * n42[o42 + 1]);
  return i42;
}
function x2(t5, r5, e5) {
  if (t5 % 1 != 0 || t5 < 0) throw new RangeError("offset is not uint");
  if (t5 + r5 > e5) throw new RangeError("Trying to access beyond buffer length");
}
function C2(t5, r5, e5, n42, i42, o42) {
  if (!u$1$1.isBuffer(t5)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (r5 > i42 || r5 < o42) throw new RangeError('"value" argument is out of bounds');
  if (e5 + n42 > t5.length) throw new RangeError("Index out of range");
}
function P2(t5, r5, e5, n42, i42, o42) {
  if (e5 + n42 > t5.length) throw new RangeError("Index out of range");
  if (e5 < 0) throw new RangeError("Index out of range");
}
function k2(t5, r5, e5, n42, o42) {
  return r5 = +r5, e5 >>>= 0, o42 || P2(t5, 0, e5, 4), i$12.write(t5, r5, e5, n42, 23, 4), e5 + 4;
}
function M2(t5, r5, e5, n42, o42) {
  return r5 = +r5, e5 >>>= 0, o42 || P2(t5, 0, e5, 8), i$12.write(t5, r5, e5, n42, 52, 8), e5 + 8;
}
u$1$1.prototype.slice = function(t5, r5) {
  var e5 = this.length;
  (t5 = ~~t5) < 0 ? (t5 += e5) < 0 && (t5 = 0) : t5 > e5 && (t5 = e5), (r5 = void 0 === r5 ? e5 : ~~r5) < 0 ? (r5 += e5) < 0 && (r5 = 0) : r5 > e5 && (r5 = e5), r5 < t5 && (r5 = t5);
  var n42 = this.subarray(t5, r5);
  return Object.setPrototypeOf(n42, u$1$1.prototype), n42;
}, u$1$1.prototype.readUIntLE = function(t5, r5, e5) {
  t5 >>>= 0, r5 >>>= 0, e5 || x2(t5, r5, this.length);
  for (var n42 = this[t5], i42 = 1, o42 = 0; ++o42 < r5 && (i42 *= 256); ) n42 += this[t5 + o42] * i42;
  return n42;
}, u$1$1.prototype.readUIntBE = function(t5, r5, e5) {
  t5 >>>= 0, r5 >>>= 0, e5 || x2(t5, r5, this.length);
  for (var n42 = this[t5 + --r5], i42 = 1; r5 > 0 && (i42 *= 256); ) n42 += this[t5 + --r5] * i42;
  return n42;
}, u$1$1.prototype.readUInt8 = function(t5, r5) {
  return t5 >>>= 0, r5 || x2(t5, 1, this.length), this[t5];
}, u$1$1.prototype.readUInt16LE = function(t5, r5) {
  return t5 >>>= 0, r5 || x2(t5, 2, this.length), this[t5] | this[t5 + 1] << 8;
}, u$1$1.prototype.readUInt16BE = function(t5, r5) {
  return t5 >>>= 0, r5 || x2(t5, 2, this.length), this[t5] << 8 | this[t5 + 1];
}, u$1$1.prototype.readUInt32LE = function(t5, r5) {
  return t5 >>>= 0, r5 || x2(t5, 4, this.length), (this[t5] | this[t5 + 1] << 8 | this[t5 + 2] << 16) + 16777216 * this[t5 + 3];
}, u$1$1.prototype.readUInt32BE = function(t5, r5) {
  return t5 >>>= 0, r5 || x2(t5, 4, this.length), 16777216 * this[t5] + (this[t5 + 1] << 16 | this[t5 + 2] << 8 | this[t5 + 3]);
}, u$1$1.prototype.readIntLE = function(t5, r5, e5) {
  t5 >>>= 0, r5 >>>= 0, e5 || x2(t5, r5, this.length);
  for (var n42 = this[t5], i42 = 1, o42 = 0; ++o42 < r5 && (i42 *= 256); ) n42 += this[t5 + o42] * i42;
  return n42 >= (i42 *= 128) && (n42 -= Math.pow(2, 8 * r5)), n42;
}, u$1$1.prototype.readIntBE = function(t5, r5, e5) {
  t5 >>>= 0, r5 >>>= 0, e5 || x2(t5, r5, this.length);
  for (var n42 = r5, i42 = 1, o42 = this[t5 + --n42]; n42 > 0 && (i42 *= 256); ) o42 += this[t5 + --n42] * i42;
  return o42 >= (i42 *= 128) && (o42 -= Math.pow(2, 8 * r5)), o42;
}, u$1$1.prototype.readInt8 = function(t5, r5) {
  return t5 >>>= 0, r5 || x2(t5, 1, this.length), 128 & this[t5] ? -1 * (255 - this[t5] + 1) : this[t5];
}, u$1$1.prototype.readInt16LE = function(t5, r5) {
  t5 >>>= 0, r5 || x2(t5, 2, this.length);
  var e5 = this[t5] | this[t5 + 1] << 8;
  return 32768 & e5 ? 4294901760 | e5 : e5;
}, u$1$1.prototype.readInt16BE = function(t5, r5) {
  t5 >>>= 0, r5 || x2(t5, 2, this.length);
  var e5 = this[t5 + 1] | this[t5] << 8;
  return 32768 & e5 ? 4294901760 | e5 : e5;
}, u$1$1.prototype.readInt32LE = function(t5, r5) {
  return t5 >>>= 0, r5 || x2(t5, 4, this.length), this[t5] | this[t5 + 1] << 8 | this[t5 + 2] << 16 | this[t5 + 3] << 24;
}, u$1$1.prototype.readInt32BE = function(t5, r5) {
  return t5 >>>= 0, r5 || x2(t5, 4, this.length), this[t5] << 24 | this[t5 + 1] << 16 | this[t5 + 2] << 8 | this[t5 + 3];
}, u$1$1.prototype.readFloatLE = function(t5, r5) {
  return t5 >>>= 0, r5 || x2(t5, 4, this.length), i$12.read(this, t5, true, 23, 4);
}, u$1$1.prototype.readFloatBE = function(t5, r5) {
  return t5 >>>= 0, r5 || x2(t5, 4, this.length), i$12.read(this, t5, false, 23, 4);
}, u$1$1.prototype.readDoubleLE = function(t5, r5) {
  return t5 >>>= 0, r5 || x2(t5, 8, this.length), i$12.read(this, t5, true, 52, 8);
}, u$1$1.prototype.readDoubleBE = function(t5, r5) {
  return t5 >>>= 0, r5 || x2(t5, 8, this.length), i$12.read(this, t5, false, 52, 8);
}, u$1$1.prototype.writeUIntLE = function(t5, r5, e5, n42) {
  (t5 = +t5, r5 >>>= 0, e5 >>>= 0, n42) || C2(this, t5, r5, e5, Math.pow(2, 8 * e5) - 1, 0);
  var i42 = 1, o42 = 0;
  for (this[r5] = 255 & t5; ++o42 < e5 && (i42 *= 256); ) this[r5 + o42] = t5 / i42 & 255;
  return r5 + e5;
}, u$1$1.prototype.writeUIntBE = function(t5, r5, e5, n42) {
  (t5 = +t5, r5 >>>= 0, e5 >>>= 0, n42) || C2(this, t5, r5, e5, Math.pow(2, 8 * e5) - 1, 0);
  var i42 = e5 - 1, o42 = 1;
  for (this[r5 + i42] = 255 & t5; --i42 >= 0 && (o42 *= 256); ) this[r5 + i42] = t5 / o42 & 255;
  return r5 + e5;
}, u$1$1.prototype.writeUInt8 = function(t5, r5, e5) {
  return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 1, 255, 0), this[r5] = 255 & t5, r5 + 1;
}, u$1$1.prototype.writeUInt16LE = function(t5, r5, e5) {
  return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 2, 65535, 0), this[r5] = 255 & t5, this[r5 + 1] = t5 >>> 8, r5 + 2;
}, u$1$1.prototype.writeUInt16BE = function(t5, r5, e5) {
  return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 2, 65535, 0), this[r5] = t5 >>> 8, this[r5 + 1] = 255 & t5, r5 + 2;
}, u$1$1.prototype.writeUInt32LE = function(t5, r5, e5) {
  return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 4, 4294967295, 0), this[r5 + 3] = t5 >>> 24, this[r5 + 2] = t5 >>> 16, this[r5 + 1] = t5 >>> 8, this[r5] = 255 & t5, r5 + 4;
}, u$1$1.prototype.writeUInt32BE = function(t5, r5, e5) {
  return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 4, 4294967295, 0), this[r5] = t5 >>> 24, this[r5 + 1] = t5 >>> 16, this[r5 + 2] = t5 >>> 8, this[r5 + 3] = 255 & t5, r5 + 4;
}, u$1$1.prototype.writeIntLE = function(t5, r5, e5, n42) {
  if (t5 = +t5, r5 >>>= 0, !n42) {
    var i42 = Math.pow(2, 8 * e5 - 1);
    C2(this, t5, r5, e5, i42 - 1, -i42);
  }
  var o42 = 0, f42 = 1, u42 = 0;
  for (this[r5] = 255 & t5; ++o42 < e5 && (f42 *= 256); ) t5 < 0 && 0 === u42 && 0 !== this[r5 + o42 - 1] && (u42 = 1), this[r5 + o42] = (t5 / f42 >> 0) - u42 & 255;
  return r5 + e5;
}, u$1$1.prototype.writeIntBE = function(t5, r5, e5, n42) {
  if (t5 = +t5, r5 >>>= 0, !n42) {
    var i42 = Math.pow(2, 8 * e5 - 1);
    C2(this, t5, r5, e5, i42 - 1, -i42);
  }
  var o42 = e5 - 1, f42 = 1, u42 = 0;
  for (this[r5 + o42] = 255 & t5; --o42 >= 0 && (f42 *= 256); ) t5 < 0 && 0 === u42 && 0 !== this[r5 + o42 + 1] && (u42 = 1), this[r5 + o42] = (t5 / f42 >> 0) - u42 & 255;
  return r5 + e5;
}, u$1$1.prototype.writeInt8 = function(t5, r5, e5) {
  return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 1, 127, -128), t5 < 0 && (t5 = 255 + t5 + 1), this[r5] = 255 & t5, r5 + 1;
}, u$1$1.prototype.writeInt16LE = function(t5, r5, e5) {
  return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 2, 32767, -32768), this[r5] = 255 & t5, this[r5 + 1] = t5 >>> 8, r5 + 2;
}, u$1$1.prototype.writeInt16BE = function(t5, r5, e5) {
  return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 2, 32767, -32768), this[r5] = t5 >>> 8, this[r5 + 1] = 255 & t5, r5 + 2;
}, u$1$1.prototype.writeInt32LE = function(t5, r5, e5) {
  return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 4, 2147483647, -2147483648), this[r5] = 255 & t5, this[r5 + 1] = t5 >>> 8, this[r5 + 2] = t5 >>> 16, this[r5 + 3] = t5 >>> 24, r5 + 4;
}, u$1$1.prototype.writeInt32BE = function(t5, r5, e5) {
  return t5 = +t5, r5 >>>= 0, e5 || C2(this, t5, r5, 4, 2147483647, -2147483648), t5 < 0 && (t5 = 4294967295 + t5 + 1), this[r5] = t5 >>> 24, this[r5 + 1] = t5 >>> 16, this[r5 + 2] = t5 >>> 8, this[r5 + 3] = 255 & t5, r5 + 4;
}, u$1$1.prototype.writeFloatLE = function(t5, r5, e5) {
  return k2(this, t5, r5, true, e5);
}, u$1$1.prototype.writeFloatBE = function(t5, r5, e5) {
  return k2(this, t5, r5, false, e5);
}, u$1$1.prototype.writeDoubleLE = function(t5, r5, e5) {
  return M2(this, t5, r5, true, e5);
}, u$1$1.prototype.writeDoubleBE = function(t5, r5, e5) {
  return M2(this, t5, r5, false, e5);
}, u$1$1.prototype.copy = function(t5, r5, e5, n42) {
  if (!u$1$1.isBuffer(t5)) throw new TypeError("argument should be a Buffer");
  if (e5 || (e5 = 0), n42 || 0 === n42 || (n42 = this.length), r5 >= t5.length && (r5 = t5.length), r5 || (r5 = 0), n42 > 0 && n42 < e5 && (n42 = e5), n42 === e5) return 0;
  if (0 === t5.length || 0 === this.length) return 0;
  if (r5 < 0) throw new RangeError("targetStart out of bounds");
  if (e5 < 0 || e5 >= this.length) throw new RangeError("Index out of range");
  if (n42 < 0) throw new RangeError("sourceEnd out of bounds");
  n42 > this.length && (n42 = this.length), t5.length - r5 < n42 - e5 && (n42 = t5.length - r5 + e5);
  var i42 = n42 - e5;
  if (this === t5 && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(r5, e5, n42);
  else if (this === t5 && e5 < r5 && r5 < n42) for (var o42 = i42 - 1; o42 >= 0; --o42) t5[o42 + r5] = this[o42 + e5];
  else Uint8Array.prototype.set.call(t5, this.subarray(e5, n42), r5);
  return i42;
}, u$1$1.prototype.fill = function(t5, r5, e5, n42) {
  if ("string" == typeof t5) {
    if ("string" == typeof r5 ? (n42 = r5, r5 = 0, e5 = this.length) : "string" == typeof e5 && (n42 = e5, e5 = this.length), void 0 !== n42 && "string" != typeof n42) throw new TypeError("encoding must be a string");
    if ("string" == typeof n42 && !u$1$1.isEncoding(n42)) throw new TypeError("Unknown encoding: " + n42);
    if (1 === t5.length) {
      var i42 = t5.charCodeAt(0);
      ("utf8" === n42 && i42 < 128 || "latin1" === n42) && (t5 = i42);
    }
  } else "number" == typeof t5 ? t5 &= 255 : "boolean" == typeof t5 && (t5 = Number(t5));
  if (r5 < 0 || this.length < r5 || this.length < e5) throw new RangeError("Out of range index");
  if (e5 <= r5) return this;
  var o42;
  if (r5 >>>= 0, e5 = void 0 === e5 ? this.length : e5 >>> 0, t5 || (t5 = 0), "number" == typeof t5) for (o42 = r5; o42 < e5; ++o42) this[o42] = t5;
  else {
    var f42 = u$1$1.isBuffer(t5) ? t5 : u$1$1.from(t5, n42), s42 = f42.length;
    if (0 === s42) throw new TypeError('The value "' + t5 + '" is invalid for argument "value"');
    for (o42 = 0; o42 < e5 - r5; ++o42) this[o42 + r5] = f42[o42 % s42];
  }
  return this;
};
var j2 = /[^+/0-9A-Za-z-_]/g;
function _2(t5, r5) {
  var e5;
  r5 = r5 || 1 / 0;
  for (var n42 = t5.length, i42 = null, o42 = [], f42 = 0; f42 < n42; ++f42) {
    if ((e5 = t5.charCodeAt(f42)) > 55295 && e5 < 57344) {
      if (!i42) {
        if (e5 > 56319) {
          (r5 -= 3) > -1 && o42.push(239, 191, 189);
          continue;
        }
        if (f42 + 1 === n42) {
          (r5 -= 3) > -1 && o42.push(239, 191, 189);
          continue;
        }
        i42 = e5;
        continue;
      }
      if (e5 < 56320) {
        (r5 -= 3) > -1 && o42.push(239, 191, 189), i42 = e5;
        continue;
      }
      e5 = 65536 + (i42 - 55296 << 10 | e5 - 56320);
    } else i42 && (r5 -= 3) > -1 && o42.push(239, 191, 189);
    if (i42 = null, e5 < 128) {
      if ((r5 -= 1) < 0) break;
      o42.push(e5);
    } else if (e5 < 2048) {
      if ((r5 -= 2) < 0) break;
      o42.push(e5 >> 6 | 192, 63 & e5 | 128);
    } else if (e5 < 65536) {
      if ((r5 -= 3) < 0) break;
      o42.push(e5 >> 12 | 224, e5 >> 6 & 63 | 128, 63 & e5 | 128);
    } else {
      if (!(e5 < 1114112)) throw new Error("Invalid code point");
      if ((r5 -= 4) < 0) break;
      o42.push(e5 >> 18 | 240, e5 >> 12 & 63 | 128, e5 >> 6 & 63 | 128, 63 & e5 | 128);
    }
  }
  return o42;
}
function z2(t5) {
  return n$1$1.toByteArray(function(t6) {
    if ((t6 = (t6 = t6.split("=")[0]).trim().replace(j2, "")).length < 2) return "";
    for (; t6.length % 4 != 0; ) t6 += "=";
    return t6;
  }(t5));
}
function D2(t5, r5, e5, n42) {
  for (var i42 = 0; i42 < n42 && !(i42 + e5 >= r5.length || i42 >= t5.length); ++i42) r5[i42 + e5] = t5[i42];
  return i42;
}
function F2(t5, r5) {
  return t5 instanceof r5 || null != t5 && null != t5.constructor && null != t5.constructor.name && t5.constructor.name === r5.name;
}
function N2(t5) {
  return t5 != t5;
}
var Y2 = function() {
  for (var t5 = new Array(256), r5 = 0; r5 < 16; ++r5) for (var e5 = 16 * r5, n42 = 0; n42 < 16; ++n42) t5[e5 + n42] = "0123456789abcdef"[r5] + "0123456789abcdef"[n42];
  return t5;
}();
e$1$1.Buffer;
e$1$1.INSPECT_MAX_BYTES;
e$1$1.kMaxLength;
var e3 = {};
var n3 = e$1$1;
var o3 = n3.Buffer;
function t3(r5, e5) {
  for (var n42 in r5) e5[n42] = r5[n42];
}
function f3(r5, e5, n42) {
  return o3(r5, e5, n42);
}
o3.from && o3.alloc && o3.allocUnsafe && o3.allocUnsafeSlow ? e3 = n3 : (t3(n3, e3), e3.Buffer = f3), f3.prototype = Object.create(o3.prototype), t3(o3, f3), f3.from = function(r5, e5, n42) {
  if ("number" == typeof r5) throw new TypeError("Argument must not be a number");
  return o3(r5, e5, n42);
}, f3.alloc = function(r5, e5, n42) {
  if ("number" != typeof r5) throw new TypeError("Argument must be a number");
  var t5 = o3(r5);
  return void 0 !== e5 ? "string" == typeof n42 ? t5.fill(e5, n42) : t5.fill(e5) : t5.fill(0), t5;
}, f3.allocUnsafe = function(r5) {
  if ("number" != typeof r5) throw new TypeError("Argument must be a number");
  return o3(r5);
}, f3.allocUnsafeSlow = function(r5) {
  if ("number" != typeof r5) throw new TypeError("Argument must be a number");
  return n3.SlowBuffer(r5);
};
var u3 = e3;
var e$12 = {};
var s3 = u3.Buffer;
var i3 = s3.isEncoding || function(t5) {
  switch ((t5 = "" + t5) && t5.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function a3(t5) {
  var e5;
  switch (this.encoding = function(t6) {
    var e6 = function(t7) {
      if (!t7) return "utf8";
      for (var e7; ; ) switch (t7) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return t7;
        default:
          if (e7) return;
          t7 = ("" + t7).toLowerCase(), e7 = true;
      }
    }(t6);
    if ("string" != typeof e6 && (s3.isEncoding === i3 || !i3(t6))) throw new Error("Unknown encoding: " + t6);
    return e6 || t6;
  }(t5), this.encoding) {
    case "utf16le":
      this.text = h3, this.end = l3, e5 = 4;
      break;
    case "utf8":
      this.fillLast = n$12, e5 = 4;
      break;
    case "base64":
      this.text = u$12, this.end = o$12, e5 = 3;
      break;
    default:
      return this.write = f$12, this.end = c3, void 0;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s3.allocUnsafe(e5);
}
function r3(t5) {
  return t5 <= 127 ? 0 : t5 >> 5 == 6 ? 2 : t5 >> 4 == 14 ? 3 : t5 >> 3 == 30 ? 4 : t5 >> 6 == 2 ? -1 : -2;
}
function n$12(t5) {
  var e5 = this.lastTotal - this.lastNeed, s42 = function(t6, e6, s5) {
    if (128 != (192 & e6[0])) return t6.lastNeed = 0, "\\uFFFD";
    if (t6.lastNeed > 1 && e6.length > 1) {
      if (128 != (192 & e6[1])) return t6.lastNeed = 1, "\\uFFFD";
      if (t6.lastNeed > 2 && e6.length > 2 && 128 != (192 & e6[2])) return t6.lastNeed = 2, "\\uFFFD";
    }
  }(this, t5);
  return void 0 !== s42 ? s42 : this.lastNeed <= t5.length ? (t5.copy(this.lastChar, e5, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t5.copy(this.lastChar, e5, 0, t5.length), this.lastNeed -= t5.length, void 0);
}
function h3(t5, e5) {
  if ((t5.length - e5) % 2 == 0) {
    var s42 = t5.toString("utf16le", e5);
    if (s42) {
      var i42 = s42.charCodeAt(s42.length - 1);
      if (i42 >= 55296 && i42 <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t5[t5.length - 2], this.lastChar[1] = t5[t5.length - 1], s42.slice(0, -1);
    }
    return s42;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t5[t5.length - 1], t5.toString("utf16le", e5, t5.length - 1);
}
function l3(t5) {
  var e5 = t5 && t5.length ? this.write(t5) : "";
  if (this.lastNeed) {
    var s42 = this.lastTotal - this.lastNeed;
    return e5 + this.lastChar.toString("utf16le", 0, s42);
  }
  return e5;
}
function u$12(t5, e5) {
  var s42 = (t5.length - e5) % 3;
  return 0 === s42 ? t5.toString("base64", e5) : (this.lastNeed = 3 - s42, this.lastTotal = 3, 1 === s42 ? this.lastChar[0] = t5[t5.length - 1] : (this.lastChar[0] = t5[t5.length - 2], this.lastChar[1] = t5[t5.length - 1]), t5.toString("base64", e5, t5.length - s42));
}
function o$12(t5) {
  var e5 = t5 && t5.length ? this.write(t5) : "";
  return this.lastNeed ? e5 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e5;
}
function f$12(t5) {
  return t5.toString(this.encoding);
}
function c3(t5) {
  return t5 && t5.length ? this.write(t5) : "";
}
e$12.StringDecoder = a3, a3.prototype.write = function(t5) {
  if (0 === t5.length) return "";
  var e5, s42;
  if (this.lastNeed) {
    if (void 0 === (e5 = this.fillLast(t5))) return "";
    s42 = this.lastNeed, this.lastNeed = 0;
  } else s42 = 0;
  return s42 < t5.length ? e5 ? e5 + this.text(t5, s42) : this.text(t5, s42) : e5 || "";
}, a3.prototype.end = function(t5) {
  var e5 = t5 && t5.length ? this.write(t5) : "";
  return this.lastNeed ? e5 + "\\uFFFD" : e5;
}, a3.prototype.text = function(t5, e5) {
  var s42 = function(t6, e6, s5) {
    var i5 = e6.length - 1;
    if (i5 < s5) return 0;
    var a42 = r3(e6[i5]);
    if (a42 >= 0) return a42 > 0 && (t6.lastNeed = a42 - 1), a42;
    if (--i5 < s5 || -2 === a42) return 0;
    if ((a42 = r3(e6[i5])) >= 0) return a42 > 0 && (t6.lastNeed = a42 - 2), a42;
    if (--i5 < s5 || -2 === a42) return 0;
    if ((a42 = r3(e6[i5])) >= 0) return a42 > 0 && (2 === a42 ? a42 = 0 : t6.lastNeed = a42 - 3), a42;
    return 0;
  }(this, t5, e5);
  if (!this.lastNeed) return t5.toString("utf8", e5);
  this.lastTotal = s42;
  var i42 = t5.length - (s42 - this.lastNeed);
  return t5.copy(this.lastChar, 0, i42), t5.toString("utf8", e5, i42);
}, a3.prototype.fillLast = function(t5) {
  if (this.lastNeed <= t5.length) return t5.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  t5.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t5.length), this.lastNeed -= t5.length;
};
var exports$2$1 = {};
var _dewExec$2$1 = false;
function dew$2$1() {
  if (_dewExec$2$1) return exports$2$1;
  _dewExec$2$1 = true;
  exports$2$1.byteLength = byteLength;
  exports$2$1.toByteArray = toByteArray;
  exports$2$1.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i42 = 0, len = code.length; i42 < len; ++i42) {
    lookup[i42] = code[i42];
    revLookup[code.charCodeAt(i42)] = i42;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i5;
    for (i5 = 0; i5 < len2; i5 += 4) {
      tmp = revLookup[b64.charCodeAt(i5)] << 18 | revLookup[b64.charCodeAt(i5 + 1)] << 12 | revLookup[b64.charCodeAt(i5 + 2)] << 6 | revLookup[b64.charCodeAt(i5 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i5)] << 2 | revLookup[b64.charCodeAt(i5 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i5)] << 10 | revLookup[b64.charCodeAt(i5 + 1)] << 4 | revLookup[b64.charCodeAt(i5 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i5 = start; i5 < end; i5 += 3) {
      tmp = (uint8[i5] << 16 & 16711680) + (uint8[i5 + 1] << 8 & 65280) + (uint8[i5 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i5 = 0, len22 = len2 - extraBytes; i5 < len22; i5 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i5, i5 + maxChunkLength > len22 ? len22 : i5 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$2$1;
}
var exports$1$1 = {};
var _dewExec$1$1 = false;
function dew$1$1() {
  if (_dewExec$1$1) return exports$1$1;
  _dewExec$1$1 = true;
  exports$1$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e5, m4;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i42 = isLE ? nBytes - 1 : 0;
    var d4 = isLE ? -1 : 1;
    var s42 = buffer2[offset + i42];
    i42 += d4;
    e5 = s42 & (1 << -nBits) - 1;
    s42 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e5 = e5 * 256 + buffer2[offset + i42], i42 += d4, nBits -= 8) {
    }
    m4 = e5 & (1 << -nBits) - 1;
    e5 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m4 = m4 * 256 + buffer2[offset + i42], i42 += d4, nBits -= 8) {
    }
    if (e5 === 0) {
      e5 = 1 - eBias;
    } else if (e5 === eMax) {
      return m4 ? NaN : (s42 ? -1 : 1) * Infinity;
    } else {
      m4 = m4 + Math.pow(2, mLen);
      e5 = e5 - eBias;
    }
    return (s42 ? -1 : 1) * m4 * Math.pow(2, e5 - mLen);
  };
  exports$1$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e5, m4, c42;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i42 = isLE ? 0 : nBytes - 1;
    var d4 = isLE ? 1 : -1;
    var s42 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m4 = isNaN(value) ? 1 : 0;
      e5 = eMax;
    } else {
      e5 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c42 = Math.pow(2, -e5)) < 1) {
        e5--;
        c42 *= 2;
      }
      if (e5 + eBias >= 1) {
        value += rt / c42;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c42 >= 2) {
        e5++;
        c42 /= 2;
      }
      if (e5 + eBias >= eMax) {
        m4 = 0;
        e5 = eMax;
      } else if (e5 + eBias >= 1) {
        m4 = (value * c42 - 1) * Math.pow(2, mLen);
        e5 = e5 + eBias;
      } else {
        m4 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e5 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i42] = m4 & 255, i42 += d4, m4 /= 256, mLen -= 8) {
    }
    e5 = e5 << mLen | m4;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i42] = e5 & 255, i42 += d4, e5 /= 256, eLen -= 8) {
    }
    buffer2[offset + i42 - d4] |= s42 * 128;
  };
  return exports$1$1;
}
var exports$g = {};
var _dewExec$g = false;
function dew$g() {
  if (_dewExec$g) return exports$g;
  _dewExec$g = true;
  const base64 = dew$2$1();
  const ieee754 = dew$1$1();
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$g.Buffer = Buffer;
  exports$g.SlowBuffer = SlowBuffer;
  exports$g.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$g.kMaxLength = K_MAX_LENGTH;
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by \`buffer\` v5.x. Use \`buffer\` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e5) {
      return false;
    }
  }
  Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length);
    }
    const b4 = fromObject(value);
    if (b4) return b4;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i42 = 0; i42 < length; i42 += 1) {
      buf[i42] = array[i42] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer.alloc(+length);
  }
  Buffer.isBuffer = function isBuffer(b4) {
    return b4 != null && b4._isBuffer === true && b4 !== Buffer.prototype;
  };
  Buffer.compare = function compare(a42, b4) {
    if (isInstance(a42, Uint8Array)) a42 = Buffer.from(a42, a42.offset, a42.byteLength);
    if (isInstance(b4, Uint8Array)) b4 = Buffer.from(b4, b4.offset, b4.byteLength);
    if (!Buffer.isBuffer(a42) || !Buffer.isBuffer(b4)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a42 === b4) return 0;
    let x4 = a42.length;
    let y5 = b4.length;
    for (let i42 = 0, len = Math.min(x4, y5); i42 < len; ++i42) {
      if (a42[i42] !== b4[i42]) {
        x4 = a42[i42];
        y5 = b4[i42];
        break;
      }
    }
    if (x4 < y5) return -1;
    if (y5 < x4) return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer.alloc(0);
    }
    let i42;
    if (length === void 0) {
      length = 0;
      for (i42 = 0; i42 < list.length; ++i42) {
        length += list[i42].length;
      }
    }
    const buffer2 = Buffer.allocUnsafe(length);
    let pos = 0;
    for (i42 = 0; i42 < list.length; ++i42) {
      let buf = list[i42];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype._isBuffer = true;
  function swap(b4, n42, m4) {
    const i42 = b4[n42];
    b4[n42] = b4[m4];
    b4[m4] = i42;
  }
  Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i42 = 0; i42 < len; i42 += 2) {
      swap(this, i42, i42 + 1);
    }
    return this;
  };
  Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i42 = 0; i42 < len; i42 += 4) {
      swap(this, i42, i42 + 3);
      swap(this, i42 + 1, i42 + 2);
    }
    return this;
  };
  Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i42 = 0; i42 < len; i42 += 8) {
      swap(this, i42, i42 + 7);
      swap(this, i42 + 1, i42 + 6);
      swap(this, i42 + 2, i42 + 5);
      swap(this, i42 + 3, i42 + 4);
    }
    return this;
  };
  Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.toLocaleString = Buffer.prototype.toString;
  Buffer.prototype.equals = function equals(b4) {
    if (!Buffer.isBuffer(b4)) throw new TypeError("Argument must be a Buffer");
    if (this === b4) return true;
    return Buffer.compare(this, b4) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports$g.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
  }
  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x4 = thisEnd - thisStart;
    let y5 = end - start;
    const len = Math.min(x4, y5);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i42 = 0; i42 < len; ++i42) {
      if (thisCopy[i42] !== targetCopy[i42]) {
        x4 = thisCopy[i42];
        y5 = targetCopy[i42];
        break;
      }
    }
    if (x4 < y5) return -1;
    if (y5 < x4) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer.from(val, encoding);
    }
    if (Buffer.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i5) {
      if (indexSize === 1) {
        return buf[i5];
      } else {
        return buf.readUInt16BE(i5 * indexSize);
      }
    }
    let i42;
    if (dir) {
      let foundIndex = -1;
      for (i42 = byteOffset; i42 < arrLength; i42++) {
        if (read(arr, i42) === read(val, foundIndex === -1 ? 0 : i42 - foundIndex)) {
          if (foundIndex === -1) foundIndex = i42;
          if (i42 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i42 -= i42 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i42 = byteOffset; i42 >= 0; i42--) {
        let found = true;
        for (let j4 = 0; j4 < valLength; j4++) {
          if (read(arr, i42 + j4) !== read(val, j4)) {
            found = false;
            break;
          }
        }
        if (found) return i42;
      }
    }
    return -1;
  }
  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i42;
    for (i42 = 0; i42 < length; ++i42) {
      const parsed = parseInt(string.substr(i42 * 2, 2), 16);
      if (numberIsNaN(parsed)) return i42;
      buf[offset + i42] = parsed;
    }
    return i42;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i42 = start;
    while (i42 < end) {
      const firstByte = buf[i42];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i42 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i42 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i42 + 1];
            thirdByte = buf[i42 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i42 + 1];
            thirdByte = buf[i42 + 2];
            fourthByte = buf[i42 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i42 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i42 = 0;
    while (i42 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i42, i42 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i42 = start; i42 < end; ++i42) {
      ret += String.fromCharCode(buf[i42] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i42 = start; i42 < end; ++i42) {
      ret += String.fromCharCode(buf[i42]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i42 = start; i42 < end; ++i42) {
      out += hexSliceLookupTable[buf[i42]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i42 = 0; i42 < bytes.length - 1; i42 += 2) {
      res += String.fromCharCode(bytes[i42] + bytes[i42 + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i42 = 0;
    while (++i42 < byteLength2 && (mul *= 256)) {
      val += this[offset + i42] * mul;
    }
    return val;
  };
  Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i42 = 0;
    while (++i42 < byteLength2 && (mul *= 256)) {
      val += this[offset + i42] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let i42 = byteLength2;
    let mul = 1;
    let val = this[offset + --i42];
    while (i42 > 0 && (mul *= 256)) {
      val += this[offset + --i42] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i42 = 0;
    this[offset] = value & 255;
    while (++i42 < byteLength2 && (mul *= 256)) {
      this[offset + i42] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i42 = byteLength2 - 1;
    let mul = 1;
    this[offset + i42] = value & 255;
    while (--i42 >= 0 && (mul *= 256)) {
      this[offset + i42] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i42 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i42 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i42 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i42] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i42 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i42] = value & 255;
    while (--i42 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i42 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i42] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i42;
    if (typeof val === "number") {
      for (i42 = start; i42 < end; ++i42) {
        this[i42] = val;
      }
    } else {
      const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i42 = 0; i42 < end - start; ++i42) {
        this[i42 + start] = bytes[i42 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E4(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = \`\${this.name} [\${sym}]\`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return \`\${this.name} [\${sym}]: \${this.message}\`;
      }
    };
  }
  E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2) {
      return \`\${name2} is outside of buffer bounds\`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E4("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return \`The "\${name2}" argument must be of type number. Received type \${typeof actual}\`;
  }, TypeError);
  E4("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = \`The value of "\${str}" is out of range.\`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += \` It must be \${range}. Received \${received}\`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i42 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i42 >= start + 4; i42 -= 3) {
      res = \`_\${val.slice(i42 - 3, i42)}\${res}\`;
    }
    return \`\${val.slice(0, i42)}\${res}\`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n42 = typeof min === "bigint" ? "n" : "";
      let range;
      {
        if (min === 0 || min === BigInt(0)) {
          range = \`>= 0\${n42} and < 2\${n42} ** \${(byteLength2 + 1) * 8}\${n42}\`;
        } else {
          range = \`>= -(2\${n42} ** \${(byteLength2 + 1) * 8 - 1}\${n42}) and < 2 ** \${(byteLength2 + 1) * 8 - 1}\${n42}\`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE("offset", \`>= \${0} and <= \${length}\`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i42 = 0; i42 < length; ++i42) {
      codePoint = string.charCodeAt(i42);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i42 + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i42 = 0; i42 < str.length; ++i42) {
      byteArray.push(str.charCodeAt(i42) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c42, hi, lo;
    const byteArray = [];
    for (let i42 = 0; i42 < str.length; ++i42) {
      if ((units -= 2) < 0) break;
      c42 = str.charCodeAt(i42);
      hi = c42 >> 8;
      lo = c42 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i42;
    for (i42 = 0; i42 < length; ++i42) {
      if (i42 + offset >= dst.length || i42 >= src.length) break;
      dst[i42 + offset] = src[i42];
    }
    return i42;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i42 = 0; i42 < 16; ++i42) {
      const i16 = i42 * 16;
      for (let j4 = 0; j4 < 16; ++j4) {
        table[i16 + j4] = alphabet[i42] + alphabet[j4];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports$g;
}
var buffer = dew$g();
buffer.Buffer;
buffer.INSPECT_MAX_BYTES;
buffer.kMaxLength;
var exports$f = {};
var _dewExec$f = false;
function dew$f() {
  if (_dewExec$f) return exports$f;
  _dewExec$f = true;
  if (typeof Object.create === "function") {
    exports$f = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    exports$f = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return exports$f;
}
var exports$e = {};
var _dewExec$e = false;
function dew$e() {
  if (_dewExec$e) return exports$e;
  _dewExec$e = true;
  exports$e = y.EventEmitter;
  return exports$e;
}
var exports$d = {};
var _dewExec$d = false;
function dew$d() {
  if (_dewExec$d) return exports$d;
  _dewExec$d = true;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i42 = 1; i42 < arguments.length; i42++) {
      var source = arguments[i42] != null ? arguments[i42] : {};
      if (i42 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i42 = 0; i42 < props.length; i42++) {
      var descriptor = props[i42];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    return Constructor;
  }
  var _require = buffer, Buffer = _require.Buffer;
  var _require2 = X, inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
  }
  exports$d = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v5) {
        var entry = {
          data: v5,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v5) {
        var entry = {
          data: v5,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s42) {
        if (this.length === 0) return "";
        var p42 = this.head;
        var ret = "" + p42.data;
        while (p42 = p42.next) {
          ret += s42 + p42.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n42) {
        if (this.length === 0) return Buffer.alloc(0);
        var ret = Buffer.allocUnsafe(n42 >>> 0);
        var p42 = this.head;
        var i42 = 0;
        while (p42) {
          copyBuffer(p42.data, ret, i42);
          i42 += p42.data.length;
          p42 = p42.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n42, hasStrings) {
        var ret;
        if (n42 < this.head.data.length) {
          ret = this.head.data.slice(0, n42);
          this.head.data = this.head.data.slice(n42);
        } else if (n42 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n42) : this._getBuffer(n42);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n42) {
        var p42 = this.head;
        var c42 = 1;
        var ret = p42.data;
        n42 -= ret.length;
        while (p42 = p42.next) {
          var str = p42.data;
          var nb = n42 > str.length ? str.length : n42;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n42);
          n42 -= nb;
          if (n42 === 0) {
            if (nb === str.length) {
              ++c42;
              if (p42.next) this.head = p42.next;
              else this.head = this.tail = null;
            } else {
              this.head = p42;
              p42.data = str.slice(nb);
            }
            break;
          }
          ++c42;
        }
        this.length -= c42;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n42) {
        var ret = Buffer.allocUnsafe(n42);
        var p42 = this.head;
        var c42 = 1;
        p42.data.copy(ret);
        n42 -= p42.data.length;
        while (p42 = p42.next) {
          var buf = p42.data;
          var nb = n42 > buf.length ? buf.length : n42;
          buf.copy(ret, ret.length - n42, 0, nb);
          n42 -= nb;
          if (n42 === 0) {
            if (nb === buf.length) {
              ++c42;
              if (p42.next) this.head = p42.next;
              else this.head = this.tail = null;
            } else {
              this.head = p42;
              p42.data = buf.slice(nb);
            }
            break;
          }
          ++c42;
        }
        this.length -= c42;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_4, options) {
        return inspect(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return exports$d;
}
var exports$c = {};
var _dewExec$c = false;
function dew$c() {
  if (_dewExec$c) return exports$c;
  _dewExec$c = true;
  var process$1 = process;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
  }
  exports$c = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return exports$c;
}
var exports$b = {};
var _dewExec$b = false;
function dew$b() {
  if (_dewExec$b) return exports$b;
  _dewExec$b = true;
  const codes2 = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes2[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i42) => String(i42));
      if (len > 2) {
        return \`one of \${thing} \${expected.slice(0, len - 1).join(", ")}, or \` + expected[len - 1];
      } else if (len === 2) {
        return \`one of \${thing} \${expected[0]} or \${expected[1]}\`;
      } else {
        return \`of \${thing} \${expected[0]}\`;
      }
    } else {
      return \`of \${thing} \${String(expected)}\`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
    return 'The value "' + value + '" is invalid for option "' + name2 + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name2, " argument")) {
      msg = \`The \${name2} \${determiner} \${oneOf(expected, "type")}\`;
    } else {
      const type = includes(name2, ".") ? "property" : "argument";
      msg = \`The "\${name2}" \${type} \${determiner} \${oneOf(expected, "type")}\`;
    }
    msg += \`. Received type \${typeof actual}\`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
    return "The " + name2 + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name2) {
    return "Cannot call " + name2 + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports$b.codes = codes2;
  return exports$b;
}
var exports$a = {};
var _dewExec$a = false;
function dew$a() {
  if (_dewExec$a) return exports$a;
  _dewExec$a = true;
  var ERR_INVALID_OPT_VALUE = dew$b().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name2 = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name2, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  exports$a = {
    getHighWaterMark
  };
  return exports$a;
}
var exports$9 = {};
var _dewExec$9 = false;
var _global$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
function dew$9() {
  if (_dewExec$9) return exports$9;
  _dewExec$9 = true;
  exports$9 = deprecate;
  function deprecate(fn, msg) {
    if (config2("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config2("throwDeprecation")) {
          throw new Error(msg);
        } else if (config2("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this || _global$2, arguments);
    }
    return deprecated;
  }
  function config2(name2) {
    try {
      if (!_global$2.localStorage) return false;
    } catch (_4) {
      return false;
    }
    var val = _global$2.localStorage[name2];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
  }
  return exports$9;
}
var exports$8 = {};
var _dewExec$8 = false;
var _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
function dew$8() {
  if (_dewExec$8) return exports$8;
  _dewExec$8 = true;
  var process$1 = process;
  exports$8 = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: dew$9()
  };
  var Stream = dew$e();
  var Buffer = buffer.Buffer;
  var OurUint8Array = _global$1.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = dew$c();
  var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  dew$f()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || dew$7();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_4) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || dew$7();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state) || stream.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l42 = state.bufferedRequestCount;
      var buffer2 = new Array(l42);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending) endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process$1.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished) process$1.nextTick(cb);
      else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return exports$8;
}
var exports$7 = {};
var _dewExec$7 = false;
function dew$7() {
  if (_dewExec$7) return exports$7;
  _dewExec$7 = true;
  var process$1 = process;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  exports$7 = Duplex;
  var Readable2 = dew$3();
  var Writable = dew$8();
  dew$f()(Duplex, Readable2);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v5 = 0; v5 < keys.length; v5++) {
      var method = keys[v5];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return exports$7;
}
var exports$6 = {};
var _dewExec$6 = false;
function dew$6() {
  if (_dewExec$6) return exports$6;
  _dewExec$6 = true;
  var ERR_STREAM_PREMATURE_CLOSE = dew$b().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once2(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop2() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once2(callback || noop2);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();
      else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  exports$6 = eos;
  return exports$6;
}
var exports$5 = {};
var _dewExec$5 = false;
function dew$5() {
  if (_dewExec$5) return exports$5;
  _dewExec$5 = true;
  var process$1 = process;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished = dew$6();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult2(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult2(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult2(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult2(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult2(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult2(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult2(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult2(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult2(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  exports$5 = createReadableStreamAsyncIterator;
  return exports$5;
}
var exports$4 = {};
var _dewExec$4 = false;
function dew$4() {
  if (_dewExec$4) return exports$4;
  _dewExec$4 = true;
  exports$4 = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return exports$4;
}
var exports$3 = {};
var _dewExec$3 = false;
var _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
function dew$3() {
  if (_dewExec$3) return exports$3;
  _dewExec$3 = true;
  var process$1 = process;
  exports$3 = Readable2;
  var Duplex;
  Readable2.ReadableState = ReadableState;
  y.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = dew$e();
  var Buffer = buffer.Buffer;
  var OurUint8Array = _global2.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = X;
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = dew$d();
  var destroyImpl = dew$c();
  var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  dew$f()(Readable2, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener2(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || dew$7();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = e$12.StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || dew$7();
    if (!(this instanceof Readable2)) return new Readable2(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
            else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) state.buffer.unshift(chunk);
      else state.buffer.push(chunk);
      if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = e$12.StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p42 = this._readableState.buffer.head;
    var content = "";
    while (p42 !== null) {
      content += decoder.write(p42.data);
      p42 = p42.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n42) {
    if (n42 >= MAX_HWM) {
      n42 = MAX_HWM;
    } else {
      n42--;
      n42 |= n42 >>> 1;
      n42 |= n42 >>> 2;
      n42 |= n42 >>> 4;
      n42 |= n42 >>> 8;
      n42 |= n42 >>> 16;
      n42++;
    }
    return n42;
  }
  function howMuchToRead(n42, state) {
    if (n42 <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n42 !== n42) {
      if (state.flowing && state.length) return state.buffer.head.data.length;
      else return state.length;
    }
    if (n42 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n42);
    if (n42 <= state.length) return n42;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable2.prototype.read = function(n42) {
    debug("read", n42);
    n42 = parseInt(n42, 10);
    var state = this._readableState;
    var nOrig = n42;
    if (n42 !== 0) state.emittedReadable = false;
    if (n42 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n42 = howMuchToRead(n42, state);
    if (n42 === 0 && state.ended) {
      if (state.length === 0) endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n42 < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0) state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading) n42 = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n42 > 0) ret = fromList(n42, state);
    else ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n42 = 0;
    } else {
      state.length -= n42;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended) state.needReadable = true;
      if (nOrig !== n42 && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable2.prototype._read = function(n42) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process$1.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener2(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0) return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes) return this;
      if (!dest) dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i42 = 0; i42 < len; i42++) {
        dests[i42].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  Readable2.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable2.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }
  Readable2.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder) chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i42 in stream) {
      if (this[i42] === void 0 && typeof stream[i42] === "function") {
        this[i42] = /* @__PURE__ */ function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i42);
      }
    }
    for (var n42 = 0; n42 < kProxyEvents.length; n42++) {
      stream.on(kProxyEvents[n42], this.emit.bind(this, kProxyEvents[n42]));
    }
    this._read = function(n5) {
      debug("wrapped _read", n5);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable2.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = dew$5();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable2._fromList = fromList;
  Object.defineProperty(Readable2.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n42, state) {
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n42 || n42 >= state.length) {
      if (state.decoder) ret = state.buffer.join("");
      else if (state.buffer.length === 1) ret = state.buffer.first();
      else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n42, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process$1.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable2.from = function(iterable, opts) {
      if (from === void 0) {
        from = dew$4();
      }
      return from(Readable2, iterable, opts);
    };
  }
  function indexOf(xs, x4) {
    for (var i42 = 0, l42 = xs.length; i42 < l42; i42++) {
      if (xs[i42] === x4) return i42;
    }
    return -1;
  }
  return exports$3;
}
var exports$22 = {};
var _dewExec$22 = false;
function dew$22() {
  if (_dewExec$22) return exports$22;
  _dewExec$22 = true;
  exports$22 = Transform;
  var _require$codes = dew$b().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = dew$7();
  dew$f()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n42) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return exports$22;
}
var exports$12 = {};
var _dewExec$12 = false;
function dew$12() {
  if (_dewExec$12) return exports$12;
  _dewExec$12 = true;
  exports$12 = PassThrough;
  var Transform = dew$22();
  dew$f()(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return exports$12;
}
var exports3 = {};
var _dewExec3 = false;
function dew3() {
  if (_dewExec3) return exports3;
  _dewExec3 = true;
  var eos;
  function once2(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = dew$b().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop2(err) {
    if (err) throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once2(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = dew$6();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest(stream)) return stream.abort();
      if (typeof stream.destroy === "function") return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length) return noop2;
    if (typeof streams[streams.length - 1] !== "function") return noop2;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i42) {
      var reading = i42 < streams.length - 1;
      var writing = i42 > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error) error = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  exports3 = pipeline;
  return exports3;
}
X._extend;
X.callbackify;
X.debuglog;
X.deprecate;
X.format;
X.inherits;
X.inspect;
X.isArray;
X.isBoolean;
X.isBuffer;
X.isDate;
X.isError;
X.isFunction;
X.isNull;
X.isNullOrUndefined;
X.isNumber;
X.isObject;
X.isPrimitive;
X.isRegExp;
X.isString;
X.isSymbol;
X.isUndefined;
X.log;
var promisify2 = X.promisify;
X.types;
X.TextEncoder = globalThis.TextEncoder;
X.TextDecoder = globalThis.TextDecoder;
var exports$13 = {};
var _dewExec4 = false;
var _global3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : globalThis;
function dew4() {
  if (_dewExec4) return exports$13;
  _dewExec4 = true;
  exports$13 = Stream;
  var EE = y.EventEmitter;
  var inherits = dew$f();
  inherits(Stream, EE);
  Stream.Readable = dew$3();
  Stream.Writable = dew$8();
  Stream.Duplex = dew$7();
  Stream.Transform = dew$22();
  Stream.PassThrough = dew$12();
  Stream.finished = dew$6();
  Stream.pipeline = dew3();
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this || _global3);
  }
  Stream.prototype.pipe = function(dest, options) {
    var source = this || _global3;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this || _global3, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  return exports$13;
}
var exports4 = dew4();
var Readable = exports4.Readable;
Readable.wrap = function(src, options) {
  options = Object.assign({ objectMode: src.readableObjectMode != null || src.objectMode != null || true }, options);
  options.destroy = function(err, callback) {
    src.destroy(err);
    callback(err);
  };
  return new Readable(options).wrap(src);
};
exports4.Writable;
exports4.Duplex;
exports4.Transform;
exports4.PassThrough;
exports4.finished;
exports4.pipeline;
exports4.Stream;
({
  finished: promisify2(exports4.finished),
  pipeline: promisify2(exports4.pipeline)
});
function e4(e5, r5) {
  if (null == e5) throw new TypeError("Cannot convert first argument to object");
  for (var t5 = Object(e5), n42 = 1; n42 < arguments.length; n42++) {
    var o42 = arguments[n42];
    if (null != o42) for (var a42 = Object.keys(Object(o42)), l42 = 0, i42 = a42.length; l42 < i42; l42++) {
      var c42 = a42[l42], b4 = Object.getOwnPropertyDescriptor(o42, c42);
      void 0 !== b4 && b4.enumerable && (t5[c42] = o42[c42]);
    }
  }
  return t5;
}
var r4 = { assign: e4, polyfill: function() {
  Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: e4 });
} };
var t4;
var e$13 = Object.prototype.toString;
var r$12 = function(t5) {
  var r5 = e$13.call(t5), n42 = "[object Arguments]" === r5;
  return n42 || (n42 = "[object Array]" !== r5 && null !== t5 && "object" == typeof t5 && "number" == typeof t5.length && t5.length >= 0 && "[object Function]" === e$13.call(t5.callee)), n42;
};
if (!Object.keys) {
  n4 = Object.prototype.hasOwnProperty, o4 = Object.prototype.toString, c4 = r$12, l4 = Object.prototype.propertyIsEnumerable, i4 = !l4.call({ toString: null }, "toString"), a4 = l4.call(function() {
  }, "prototype"), u4 = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], f4 = function(t5) {
    var e5 = t5.constructor;
    return e5 && e5.prototype === t5;
  }, p4 = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, s4 = function() {
    if ("undefined" == typeof window) return false;
    for (var t5 in window) try {
      if (!p4["$" + t5] && n4.call(window, t5) && null !== window[t5] && "object" == typeof window[t5]) try {
        f4(window[t5]);
      } catch (t6) {
        return true;
      }
    } catch (t6) {
      return true;
    }
    return false;
  }();
  t4 = function(t5) {
    var e5 = null !== t5 && "object" == typeof t5, r5 = "[object Function]" === o4.call(t5), l5 = c4(t5), p5 = e5 && "[object String]" === o4.call(t5), y5 = [];
    if (!e5 && !r5 && !l5) throw new TypeError("Object.keys called on a non-object");
    var b4 = a4 && r5;
    if (p5 && t5.length > 0 && !n4.call(t5, 0)) for (var g4 = 0; g4 < t5.length; ++g4) y5.push(String(g4));
    if (l5 && t5.length > 0) for (var h5 = 0; h5 < t5.length; ++h5) y5.push(String(h5));
    else for (var $3 in t5) b4 && "prototype" === $3 || !n4.call(t5, $3) || y5.push(String($3));
    if (i4) for (var j4 = function(t6) {
      if ("undefined" == typeof window || !s4) return f4(t6);
      try {
        return f4(t6);
      } catch (t7) {
        return false;
      }
    }(t5), w4 = 0; w4 < u4.length; ++w4) j4 && "constructor" === u4[w4] || !n4.call(t5, u4[w4]) || y5.push(u4[w4]);
    return y5;
  };
}
var n4;
var o4;
var c4;
var l4;
var i4;
var a4;
var u4;
var f4;
var p4;
var s4;
var y4 = t4;
var b3 = Array.prototype.slice;
var g3 = r$12;
var h4 = Object.keys;
var $2 = h4 ? function(t5) {
  return h4(t5);
} : y4;
var j3 = Object.keys;
$2.shim = function() {
  Object.keys ? function() {
    var t5 = Object.keys(arguments);
    return t5 && t5.length === arguments.length;
  }(1, 2) || (Object.keys = function(t5) {
    return g3(t5) ? j3(b3.call(t5)) : j3(t5);
  }) : Object.keys = $2;
  return Object.keys || $2;
};
var w3 = $2;
var r$22 = w3;
var e$22 = "function" == typeof Symbol && "symbol" == typeof Symbol("foo");
var o$13 = Object.prototype.toString;
var n$13 = Array.prototype.concat;
var a$12 = Object.defineProperty;
var c$13 = a$12 && function() {
  var t5 = {};
  try {
    for (var r5 in a$12(t5, "x", { enumerable: false, value: t5 }), t5) return false;
    return t5.x === t5;
  } catch (t6) {
    return false;
  }
}();
var l$13 = function(t5, r5, e5, n42) {
  var l42;
  (!(r5 in t5) || "function" == typeof (l42 = n42) && "[object Function]" === o$13.call(l42) && n42()) && (c$13 ? a$12(t5, r5, { configurable: true, enumerable: false, value: e5, writable: true }) : t5[r5] = e5);
};
var u$13 = function(t5, o42) {
  var a42 = arguments.length > 2 ? arguments[2] : {}, c42 = r$22(o42);
  e$22 && (c42 = n$13.call(c42, Object.getOwnPropertySymbols(o42)));
  for (var u42 = 0; u42 < c42.length; u42 += 1) l$13(t5, c42[u42], o42[c42[u42]], a42[c42[u42]]);
};
u$13.supportsDescriptors = !!c$13;
var f$13 = u$13;
var t$12 = function() {
  if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return false;
  if ("symbol" == typeof Symbol.iterator) return true;
  var t5 = {}, e5 = Symbol("test"), r5 = Object(e5);
  if ("string" == typeof e5) return false;
  if ("[object Symbol]" !== Object.prototype.toString.call(e5)) return false;
  if ("[object Symbol]" !== Object.prototype.toString.call(r5)) return false;
  for (e5 in t5[e5] = 42, t5) return false;
  if ("function" == typeof Object.keys && 0 !== Object.keys(t5).length) return false;
  if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t5).length) return false;
  var o42 = Object.getOwnPropertySymbols(t5);
  if (1 !== o42.length || o42[0] !== e5) return false;
  if (!Object.prototype.propertyIsEnumerable.call(t5, e5)) return false;
  if ("function" == typeof Object.getOwnPropertyDescriptor) {
    var n42 = Object.getOwnPropertyDescriptor(t5, e5);
    if (42 !== n42.value || true !== n42.enumerable) return false;
  }
  return true;
};
var f$22 = ("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : globalThis).Symbol;
var e$3 = t$12;
var l$22 = function() {
  return "function" == typeof f$22 && ("function" == typeof Symbol && ("symbol" == typeof f$22("foo") && ("symbol" == typeof Symbol("bar") && e$3())));
};
var t$22 = "Function.prototype.bind called on incompatible ";
var n$22 = Array.prototype.slice;
var o$22 = Object.prototype.toString;
var r$3 = function(r5) {
  var e5 = this;
  if ("function" != typeof e5 || "[object Function]" !== o$22.call(e5)) throw new TypeError(t$22 + e5);
  for (var p42, i42 = n$22.call(arguments, 1), c42 = function() {
    if (this instanceof p42) {
      var t5 = e5.apply(this, i42.concat(n$22.call(arguments)));
      return Object(t5) === t5 ? t5 : this;
    }
    return e5.apply(r5, i42.concat(n$22.call(arguments)));
  }, a42 = Math.max(0, e5.length - i42.length), l42 = [], u42 = 0; u42 < a42; u42++) l42.push("$" + u42);
  if (p42 = Function("binder", "return function (" + l42.join(",") + "){ return binder.apply(this,arguments); }")(c42), e5.prototype) {
    var y5 = function() {
    };
    y5.prototype = e5.prototype, p42.prototype = new y5(), y5.prototype = null;
  }
  return p42;
};
var e$4 = Function.prototype.bind || r$3;
var o$32 = TypeError;
var t$32 = Object.getOwnPropertyDescriptor;
if (t$32) try {
  t$32({}, "");
} catch (r5) {
  t$32 = null;
}
var n$3 = function() {
  throw new o$32();
};
var y$1 = t$32 ? function() {
  try {
    return arguments.callee, n$3;
  } catch (r5) {
    try {
      return t$32(arguments, "callee").get;
    } catch (r6) {
      return n$3;
    }
  }
}() : n$3;
var a$22 = l$22();
var i$13 = Object.getPrototypeOf || function(r5) {
  return r5.__proto__;
};
var d3 = "undefined" == typeof Uint8Array ? void 0 : i$13(Uint8Array);
var f$3 = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": a$22 ? i$13([][Symbol.iterator]()) : void 0, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": void 0, "%AsyncFunction%": void 0, "%AsyncFunctionPrototype%": void 0, "%AsyncGenerator%": void 0, "%AsyncGeneratorFunction%": void 0, "%AsyncGeneratorPrototype%": void 0, "%AsyncIteratorPrototype%": void 0, "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? void 0 : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": void 0, "%GeneratorFunction%": void 0, "%GeneratorPrototype%": void 0, "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": a$22 ? i$13(i$13([][Symbol.iterator]())) : void 0, "%JSON%": "object" == typeof JSON ? JSON : void 0, "%JSONParse%": "object" == typeof JSON ? JSON.parse : void 0, "%Map%": "undefined" == typeof Map ? void 0 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && a$22 ? i$13((/* @__PURE__ */ new Map())[Symbol.iterator]()) : void 0, "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? void 0 : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? void 0 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && a$22 ? i$13((/* @__PURE__ */ new Set())[Symbol.iterator]()) : void 0, "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": a$22 ? i$13(""[Symbol.iterator]()) : void 0, "%StringPrototype%": String.prototype, "%Symbol%": a$22 ? Symbol : void 0, "%SymbolPrototype%": a$22 ? Symbol.prototype : void 0, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": y$1, "%TypedArray%": d3, "%TypedArrayPrototype%": d3 ? d3.prototype : void 0, "%TypeError%": o$32, "%TypeErrorPrototype%": o$32.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype };
var u$23 = e$4.call(Function.call, String.prototype.replace);
var A3 = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;
var l$3 = /\\\\(\\\\)?/g;
var v4 = function(r5) {
  var e5 = [];
  return u$23(r5, A3, function(r6, o42, t5, n42) {
    e5[e5.length] = t5 ? u$23(n42, l$3, "$1") : o42 || r6;
  }), e5;
};
var P3 = function(r5, e5) {
  if (!(r5 in f$3)) throw new SyntaxError("intrinsic " + r5 + " does not exist!");
  if (void 0 === f$3[r5] && !e5) throw new o$32("intrinsic " + r5 + " exists, but is not available. Please file an issue!");
  return f$3[r5];
};
var c$22 = function(r5, e5) {
  if (0 === r5.length) throw new TypeError("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && "boolean" != typeof e5) throw new TypeError('"allowMissing" argument must be a boolean');
  for (var n42 = v4(r5), y5 = P3("%" + (n42.length > 0 ? n42[0] : "") + "%", e5), a42 = 1; a42 < n42.length; a42 += 1) if (null != y5) if (t$32 && a42 + 1 >= n42.length) {
    var i42 = t$32(y5, n42[a42]);
    if (!(n42[a42] in y5)) throw new o$32("base intrinsic for " + r5 + " exists, but the property is not available.");
    y5 = i42 ? i42.get || i42.value : y5[n42[a42]];
  } else y5 = y5[n42[a42]];
  return y5;
};
var t$4;
var p$12 = e$4;
var o$4 = c$22("%Function%");
var i$22 = o$4.apply;
var a$3 = o$4.call;
(t$4 = function() {
  return p$12.apply(a$3, arguments);
}).apply = function() {
  return p$12.apply(i$22, arguments);
};
var l$4 = t$4;
var r$4;
var n$4;
var i$3 = function(t5) {
  return t5 != t5;
};
var o$5 = (r$4 = function(t5, e5) {
  return 0 === t5 && 0 === e5 ? 1 / t5 == 1 / e5 : t5 === e5 || !(!i$3(t5) || !i$3(e5));
}, r$4);
var c$3 = (n$4 = function() {
  return "function" == typeof Object.is ? Object.is : o$5;
}, n$4);
var f$4 = f$13;
var u$3 = f$13;
var s$13 = r$4;
var a$4 = n$4;
var l$5 = function() {
  var t5 = c$3();
  return f$4(Object, { is: t5 }, { is: function() {
    return Object.is !== t5;
  } }), t5;
};
var p$2 = l$4(a$4(), Object);
u$3(p$2, { getPolyfill: a$4, implementation: s$13, shim: l$5 });
var m3 = p$2;
N3 = function(r5) {
  return r5 != r5;
};
var N3;
var e$5;
var i$4 = N3;
var n$5 = (e$5 = function() {
  return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : i$4;
}, f$13);
var t$5 = e$5;
var u$4 = f$13;
var a$5 = N3;
var m$12 = e$5;
var o$6 = function() {
  var r5 = t$5();
  return n$5(Number, { isNaN: r5 }, { isNaN: function() {
    return Number.isNaN !== r5;
  } }), r5;
};
var s$2 = m$12();
u$4(s$2, { getPolyfill: m$12, implementation: a$5, shim: o$6 });
var f$5 = s$2;
var c$4 = {};
var a$6 = false;
function i$5() {
  if (a$6) return c$4;
  function e5(t5) {
    return (e5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t6) {
      return typeof t6;
    } : function(t6) {
      return t6 && "function" == typeof Symbol && t6.constructor === Symbol && t6 !== Symbol.prototype ? "symbol" : typeof t6;
    })(t5);
  }
  function n42(t5, n5) {
    return !n5 || "object" !== e5(n5) && "function" != typeof n5 ? function(t6) {
      if (void 0 === t6) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t6;
    }(t5) : n5;
  }
  function r5(t5) {
    return (r5 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t6) {
      return t6.__proto__ || Object.getPrototypeOf(t6);
    })(t5);
  }
  function o42(t5, e6) {
    return (o42 = Object.setPrototypeOf || function(t6, e7) {
      return t6.__proto__ = e7, t6;
    })(t5, e6);
  }
  a$6 = true;
  var i42, u42, l42 = {};
  function f42(t5, e6, c42) {
    c42 || (c42 = Error);
    var a42 = function(c5) {
      function a5(o5, c6, i5) {
        var u5;
        return !function(t6, e7) {
          if (!(t6 instanceof e7)) throw new TypeError("Cannot call a class as a function");
        }(this, a5), (u5 = n42(this, r5(a5).call(this, function(t6, n5, r6) {
          return "string" == typeof e6 ? e6 : e6(t6, n5, r6);
        }(o5, c6, i5)))).code = t5, u5;
      }
      return !function(t6, e7) {
        if ("function" != typeof e7 && null !== e7) throw new TypeError("Super expression must either be null or a function");
        t6.prototype = Object.create(e7 && e7.prototype, { constructor: { value: t6, writable: true, configurable: true } }), e7 && o42(t6, e7);
      }(a5, c5), a5;
    }(c42);
    l42[t5] = a42;
  }
  function s42(t5, e6) {
    if (Array.isArray(t5)) {
      var n5 = t5.length;
      return t5 = t5.map(function(t6) {
        return String(t6);
      }), n5 > 2 ? "one of ".concat(e6, " ").concat(t5.slice(0, n5 - 1).join(", "), ", or ") + t5[n5 - 1] : 2 === n5 ? "one of ".concat(e6, " ").concat(t5[0], " or ").concat(t5[1]) : "of ".concat(e6, " ").concat(t5[0]);
    }
    return "of ".concat(e6, " ").concat(String(t5));
  }
  return f42("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), f42("ERR_INVALID_ARG_TYPE", function(t5, n5, r6) {
    var o5, c42, u5;
    if (void 0 === i42 && (i42 = tt()), i42("string" == typeof t5, "'name' must be a string"), "string" == typeof n5 && (c42 = "not ", n5.substr(0, c42.length) === c42) ? (o5 = "must not be", n5 = n5.replace(/^not /, "")) : o5 = "must be", function(t6, e6, n6) {
      return (void 0 === n6 || n6 > t6.length) && (n6 = t6.length), t6.substring(n6 - e6.length, n6) === e6;
    }(t5, " argument")) u5 = "The ".concat(t5, " ").concat(o5, " ").concat(s42(n5, "type"));
    else {
      var l5 = function(t6, e6, n6) {
        return "number" != typeof n6 && (n6 = 0), !(n6 + e6.length > t6.length) && -1 !== t6.indexOf(e6, n6);
      }(t5, ".") ? "property" : "argument";
      u5 = 'The "'.concat(t5, '" ').concat(l5, " ").concat(o5, " ").concat(s42(n5, "type"));
    }
    return u5 += ". Received type ".concat(e5(r6));
  }, TypeError), f42("ERR_INVALID_ARG_VALUE", function(e6, n5) {
    var r6 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
    void 0 === u42 && (u42 = X);
    var o5 = u42.inspect(n5);
    return o5.length > 128 && (o5 = "".concat(o5.slice(0, 128), "...")), "The argument '".concat(e6, "' ").concat(r6, ". Received ").concat(o5);
  }, TypeError), f42("ERR_INVALID_RETURN_VALUE", function(t5, n5, r6) {
    var o5;
    return o5 = r6 && r6.constructor && r6.constructor.name ? "instance of ".concat(r6.constructor.name) : "type ".concat(e5(r6)), "Expected ".concat(t5, ' to be returned from the "').concat(n5, '"') + " function but got ".concat(o5, ".");
  }, TypeError), f42("ERR_MISSING_ARGS", function() {
    for (var t5 = arguments.length, e6 = new Array(t5), n5 = 0; n5 < t5; n5++) e6[n5] = arguments[n5];
    void 0 === i42 && (i42 = tt()), i42(e6.length > 0, "At least one arg needs to be specified");
    var r6 = "The ", o5 = e6.length;
    switch (e6 = e6.map(function(t6) {
      return '"'.concat(t6, '"');
    }), o5) {
      case 1:
        r6 += "".concat(e6[0], " argument");
        break;
      case 2:
        r6 += "".concat(e6[0], " and ").concat(e6[1], " arguments");
        break;
      default:
        r6 += e6.slice(0, o5 - 1).join(", "), r6 += ", and ".concat(e6[o5 - 1], " arguments");
    }
    return "".concat(r6, " must be specified");
  }, TypeError), c$4.codes = l42, c$4;
}
var u$5 = {};
var l$6 = false;
function f$6() {
  if (l$6) return u$5;
  l$6 = true;
  var n42 = T$1;
  function r5(t5, e5, n5) {
    return e5 in t5 ? Object.defineProperty(t5, e5, { value: n5, enumerable: true, configurable: true, writable: true }) : t5[e5] = n5, t5;
  }
  function o42(t5, e5) {
    for (var n5 = 0; n5 < e5.length; n5++) {
      var r6 = e5[n5];
      r6.enumerable = r6.enumerable || false, r6.configurable = true, "value" in r6 && (r6.writable = true), Object.defineProperty(t5, r6.key, r6);
    }
  }
  function c42(t5, e5) {
    return !e5 || "object" !== y5(e5) && "function" != typeof e5 ? a42(t5) : e5;
  }
  function a42(t5) {
    if (void 0 === t5) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t5;
  }
  function f42(t5) {
    var e5 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
    return (f42 = function(t6) {
      if (null === t6 || (n5 = t6, -1 === Function.toString.call(n5).indexOf("[native code]"))) return t6;
      var n5;
      if ("function" != typeof t6) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== e5) {
        if (e5.has(t6)) return e5.get(t6);
        e5.set(t6, r6);
      }
      function r6() {
        return p42(t6, arguments, h5(this).constructor);
      }
      return r6.prototype = Object.create(t6.prototype, { constructor: { value: r6, enumerable: false, writable: true, configurable: true } }), g4(r6, t6);
    })(t5);
  }
  function s42() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if ("function" == typeof Proxy) return true;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), true;
    } catch (t5) {
      return false;
    }
  }
  function p42(t5, e5, n5) {
    return (p42 = s42() ? Reflect.construct : function(t6, e6, n6) {
      var r6 = [null];
      r6.push.apply(r6, e6);
      var o5 = new (Function.bind.apply(t6, r6))();
      return n6 && g4(o5, n6.prototype), o5;
    }).apply(null, arguments);
  }
  function g4(t5, e5) {
    return (g4 = Object.setPrototypeOf || function(t6, e6) {
      return t6.__proto__ = e6, t6;
    })(t5, e5);
  }
  function h5(t5) {
    return (h5 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t6) {
      return t6.__proto__ || Object.getPrototypeOf(t6);
    })(t5);
  }
  function y5(t5) {
    return (y5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t6) {
      return typeof t6;
    } : function(t6) {
      return t6 && "function" == typeof Symbol && t6.constructor === Symbol && t6 !== Symbol.prototype ? "symbol" : typeof t6;
    })(t5);
  }
  var b4 = X.inspect, v5 = i$5().codes.ERR_INVALID_ARG_TYPE;
  function d4(t5, e5, n5) {
    return (void 0 === n5 || n5 > t5.length) && (n5 = t5.length), t5.substring(n5 - e5.length, n5) === e5;
  }
  var m4 = "", E4 = "", w4 = "", S4 = "", j4 = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
  function O4(t5) {
    var e5 = Object.keys(t5), n5 = Object.create(Object.getPrototypeOf(t5));
    return e5.forEach(function(e6) {
      n5[e6] = t5[e6];
    }), Object.defineProperty(n5, "message", { value: t5.message }), n5;
  }
  function x4(t5) {
    return b4(t5, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
  }
  function q3(t5, e5, r6) {
    var o5 = "", c5 = "", a5 = 0, i42 = "", u42 = false, l42 = x4(t5), f5 = l42.split("\\n"), s5 = x4(e5).split("\\n"), p5 = 0, g5 = "";
    if ("strictEqual" === r6 && "object" === y5(t5) && "object" === y5(e5) && null !== t5 && null !== e5 && (r6 = "strictEqualObject"), 1 === f5.length && 1 === s5.length && f5[0] !== s5[0]) {
      var h6 = f5[0].length + s5[0].length;
      if (h6 <= 10) {
        if (!("object" === y5(t5) && null !== t5 || "object" === y5(e5) && null !== e5 || 0 === t5 && 0 === e5)) return "".concat(j4[r6], "\\n\\n") + "".concat(f5[0], " !== ").concat(s5[0], "\\n");
      } else if ("strictEqualObject" !== r6) {
        if (h6 < (n42.stderr && n42.stderr.isTTY ? n42.stderr.columns : 80)) {
          for (; f5[0][p5] === s5[0][p5]; ) p5++;
          p5 > 2 && (g5 = "\\n  ".concat(function(t6, e6) {
            if (e6 = Math.floor(e6), 0 == t6.length || 0 == e6) return "";
            var n5 = t6.length * e6;
            for (e6 = Math.floor(Math.log(e6) / Math.log(2)); e6; ) t6 += t6, e6--;
            return t6 += t6.substring(0, n5 - t6.length);
          }(" ", p5), "^"), p5 = 0);
        }
      }
    }
    for (var b5 = f5[f5.length - 1], v6 = s5[s5.length - 1]; b5 === v6 && (p5++ < 2 ? i42 = "\\n  ".concat(b5).concat(i42) : o5 = b5, f5.pop(), s5.pop(), 0 !== f5.length && 0 !== s5.length); ) b5 = f5[f5.length - 1], v6 = s5[s5.length - 1];
    var O5 = Math.max(f5.length, s5.length);
    if (0 === O5) {
      var q4 = l42.split("\\n");
      if (q4.length > 30) for (q4[26] = "".concat(m4, "...").concat(S4); q4.length > 27; ) q4.pop();
      return "".concat(j4.notIdentical, "\\n\\n").concat(q4.join("\\n"), "\\n");
    }
    p5 > 3 && (i42 = "\\n".concat(m4, "...").concat(S4).concat(i42), u42 = true), "" !== o5 && (i42 = "\\n  ".concat(o5).concat(i42), o5 = "");
    var R5 = 0, A4 = j4[r6] + "\\n".concat(E4, "+ actual").concat(S4, " ").concat(w4, "- expected").concat(S4), k4 = " ".concat(m4, "...").concat(S4, " Lines skipped");
    for (p5 = 0; p5 < O5; p5++) {
      var _4 = p5 - a5;
      if (f5.length < p5 + 1) _4 > 1 && p5 > 2 && (_4 > 4 ? (c5 += "\\n".concat(m4, "...").concat(S4), u42 = true) : _4 > 3 && (c5 += "\\n  ".concat(s5[p5 - 2]), R5++), c5 += "\\n  ".concat(s5[p5 - 1]), R5++), a5 = p5, o5 += "\\n".concat(w4, "-").concat(S4, " ").concat(s5[p5]), R5++;
      else if (s5.length < p5 + 1) _4 > 1 && p5 > 2 && (_4 > 4 ? (c5 += "\\n".concat(m4, "...").concat(S4), u42 = true) : _4 > 3 && (c5 += "\\n  ".concat(f5[p5 - 2]), R5++), c5 += "\\n  ".concat(f5[p5 - 1]), R5++), a5 = p5, c5 += "\\n".concat(E4, "+").concat(S4, " ").concat(f5[p5]), R5++;
      else {
        var T4 = s5[p5], P4 = f5[p5], I4 = P4 !== T4 && (!d4(P4, ",") || P4.slice(0, -1) !== T4);
        I4 && d4(T4, ",") && T4.slice(0, -1) === P4 && (I4 = false, P4 += ","), I4 ? (_4 > 1 && p5 > 2 && (_4 > 4 ? (c5 += "\\n".concat(m4, "...").concat(S4), u42 = true) : _4 > 3 && (c5 += "\\n  ".concat(f5[p5 - 2]), R5++), c5 += "\\n  ".concat(f5[p5 - 1]), R5++), a5 = p5, c5 += "\\n".concat(E4, "+").concat(S4, " ").concat(P4), o5 += "\\n".concat(w4, "-").concat(S4, " ").concat(T4), R5 += 2) : (c5 += o5, o5 = "", 1 !== _4 && 0 !== p5 || (c5 += "\\n  ".concat(P4), R5++));
      }
      if (R5 > 20 && p5 < O5 - 2) return "".concat(A4).concat(k4, "\\n").concat(c5, "\\n").concat(m4, "...").concat(S4).concat(o5, "\\n") + "".concat(m4, "...").concat(S4);
    }
    return "".concat(A4).concat(u42 ? k4 : "", "\\n").concat(c5).concat(o5).concat(i42).concat(g5);
  }
  var R4 = function(t5) {
    function e5(t6) {
      var r6;
      if (!function(t7, e6) {
        if (!(t7 instanceof e6)) throw new TypeError("Cannot call a class as a function");
      }(this, e5), "object" !== y5(t6) || null === t6) throw new v5("options", "Object", t6);
      var o5 = t6.message, i5 = t6.operator, u5 = t6.stackStartFn, l42 = t6.actual, f5 = t6.expected, s5 = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, null != o5) r6 = c42(this, h5(e5).call(this, String(o5)));
      else if (n42.stderr && n42.stderr.isTTY && (n42.stderr && n42.stderr.getColorDepth && 1 !== n42.stderr.getColorDepth() ? (m4 = "\\x1B[34m", E4 = "\\x1B[32m", S4 = "\\x1B[39m", w4 = "\\x1B[31m") : (m4 = "", E4 = "", S4 = "", w4 = "")), "object" === y5(l42) && null !== l42 && "object" === y5(f5) && null !== f5 && "stack" in l42 && l42 instanceof Error && "stack" in f5 && f5 instanceof Error && (l42 = O4(l42), f5 = O4(f5)), "deepStrictEqual" === i5 || "strictEqual" === i5) r6 = c42(this, h5(e5).call(this, q3(l42, f5, i5)));
      else if ("notDeepStrictEqual" === i5 || "notStrictEqual" === i5) {
        var p5 = j4[i5], g5 = x4(l42).split("\\n");
        if ("notStrictEqual" === i5 && "object" === y5(l42) && null !== l42 && (p5 = j4.notStrictEqualObject), g5.length > 30) for (g5[26] = "".concat(m4, "...").concat(S4); g5.length > 27; ) g5.pop();
        r6 = 1 === g5.length ? c42(this, h5(e5).call(this, "".concat(p5, " ").concat(g5[0]))) : c42(this, h5(e5).call(this, "".concat(p5, "\\n\\n").concat(g5.join("\\n"), "\\n")));
      } else {
        var b5 = x4(l42), d5 = "", R5 = j4[i5];
        "notDeepEqual" === i5 || "notEqual" === i5 ? (b5 = "".concat(j4[i5], "\\n\\n").concat(b5)).length > 1024 && (b5 = "".concat(b5.slice(0, 1021), "...")) : (d5 = "".concat(x4(f5)), b5.length > 512 && (b5 = "".concat(b5.slice(0, 509), "...")), d5.length > 512 && (d5 = "".concat(d5.slice(0, 509), "...")), "deepEqual" === i5 || "equal" === i5 ? b5 = "".concat(R5, "\\n\\n").concat(b5, "\\n\\nshould equal\\n\\n") : d5 = " ".concat(i5, " ").concat(d5)), r6 = c42(this, h5(e5).call(this, "".concat(b5).concat(d5)));
      }
      return Error.stackTraceLimit = s5, r6.generatedMessage = !o5, Object.defineProperty(a42(r6), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), r6.code = "ERR_ASSERTION", r6.actual = l42, r6.expected = f5, r6.operator = i5, Error.captureStackTrace && Error.captureStackTrace(a42(r6), u5), r6.stack, r6.name = "AssertionError", c42(r6);
    }
    var i42, u42;
    return !function(t6, e6) {
      if ("function" != typeof e6 && null !== e6) throw new TypeError("Super expression must either be null or a function");
      t6.prototype = Object.create(e6 && e6.prototype, { constructor: { value: t6, writable: true, configurable: true } }), e6 && g4(t6, e6);
    }(e5, t5), i42 = e5, (u42 = [{ key: "toString", value: function() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    } }, { key: b4.custom, value: function(t6, e6) {
      return b4(this, function(t7) {
        for (var e7 = 1; e7 < arguments.length; e7++) {
          var n5 = null != arguments[e7] ? arguments[e7] : {}, o5 = Object.keys(n5);
          "function" == typeof Object.getOwnPropertySymbols && (o5 = o5.concat(Object.getOwnPropertySymbols(n5).filter(function(t8) {
            return Object.getOwnPropertyDescriptor(n5, t8).enumerable;
          }))), o5.forEach(function(e8) {
            r5(t7, e8, n5[e8]);
          });
        }
        return t7;
      }({}, e6, { customInspect: false, depth: 0 }));
    } }]) && o42(i42.prototype, u42), e5;
  }(f42(Error));
  return u$5 = R4;
}
function s$3(t5, e5) {
  return function(t6) {
    if (Array.isArray(t6)) return t6;
  }(t5) || function(t6, e6) {
    var n42 = [], r5 = true, o42 = false, c42 = void 0;
    try {
      for (var a42, i42 = t6[Symbol.iterator](); !(r5 = (a42 = i42.next()).done) && (n42.push(a42.value), !e6 || n42.length !== e6); r5 = true) ;
    } catch (t7) {
      o42 = true, c42 = t7;
    } finally {
      try {
        r5 || null == i42.return || i42.return();
      } finally {
        if (o42) throw c42;
      }
    }
    return n42;
  }(t5, e5) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }();
}
function p$3(t5) {
  return (p$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t6) {
    return typeof t6;
  } : function(t6) {
    return t6 && "function" == typeof Symbol && t6.constructor === Symbol && t6 !== Symbol.prototype ? "symbol" : typeof t6;
  })(t5);
}
var g$1 = void 0 !== /a/g.flags;
var h$12 = function(t5) {
  var e5 = [];
  return t5.forEach(function(t6) {
    return e5.push(t6);
  }), e5;
};
var y$2 = function(t5) {
  var e5 = [];
  return t5.forEach(function(t6, n42) {
    return e5.push([n42, t6]);
  }), e5;
};
var b$1 = Object.is ? Object.is : m3;
var v$1 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
  return [];
};
var d$12 = Number.isNaN ? Number.isNaN : f$5;
function m$2(t5) {
  return t5.call.bind(t5);
}
var E3 = m$2(Object.prototype.hasOwnProperty);
var w$1 = m$2(Object.prototype.propertyIsEnumerable);
var S3 = m$2(Object.prototype.toString);
var j$1 = X.types;
var O3 = j$1.isAnyArrayBuffer;
var x3 = j$1.isArrayBufferView;
var q2 = j$1.isDate;
var R3 = j$1.isMap;
var A$1 = j$1.isRegExp;
var k3 = j$1.isSet;
var _3 = j$1.isNativeError;
var T3 = j$1.isBoxedPrimitive;
var P$1 = j$1.isNumberObject;
var I3 = j$1.isStringObject;
var D3 = j$1.isBooleanObject;
var F3 = j$1.isBigIntObject;
var N$1 = j$1.isSymbolObject;
var L3 = j$1.isFloat32Array;
var M3 = j$1.isFloat64Array;
function U3(t5) {
  if (0 === t5.length || t5.length > 10) return true;
  for (var e5 = 0; e5 < t5.length; e5++) {
    var n42 = t5.charCodeAt(e5);
    if (n42 < 48 || n42 > 57) return true;
  }
  return 10 === t5.length && t5 >= Math.pow(2, 32);
}
function G2(t5) {
  return Object.keys(t5).filter(U3).concat(v$1(t5).filter(Object.prototype.propertyIsEnumerable.bind(t5)));
}
function V2(t5, e5) {
  if (t5 === e5) return 0;
  for (var n42 = t5.length, r5 = e5.length, o42 = 0, c42 = Math.min(n42, r5); o42 < c42; ++o42) if (t5[o42] !== e5[o42]) {
    n42 = t5[o42], r5 = e5[o42];
    break;
  }
  return n42 < r5 ? -1 : r5 < n42 ? 1 : 0;
}
function B3(t5, e5, n42, r5) {
  if (t5 === e5) return 0 !== t5 || (!n42 || b$1(t5, e5));
  if (n42) {
    if ("object" !== p$3(t5)) return "number" == typeof t5 && d$12(t5) && d$12(e5);
    if ("object" !== p$3(e5) || null === t5 || null === e5) return false;
    if (Object.getPrototypeOf(t5) !== Object.getPrototypeOf(e5)) return false;
  } else {
    if (null === t5 || "object" !== p$3(t5)) return (null === e5 || "object" !== p$3(e5)) && t5 == e5;
    if (null === e5 || "object" !== p$3(e5)) return false;
  }
  var o42, c42, a42, i42, u42 = S3(t5);
  if (u42 !== S3(e5)) return false;
  if (Array.isArray(t5)) {
    if (t5.length !== e5.length) return false;
    var l42 = G2(t5), f42 = G2(e5);
    return l42.length === f42.length && C3(t5, e5, n42, r5, 1, l42);
  }
  if ("[object Object]" === u42 && (!R3(t5) && R3(e5) || !k3(t5) && k3(e5))) return false;
  if (q2(t5)) {
    if (!q2(e5) || Date.prototype.getTime.call(t5) !== Date.prototype.getTime.call(e5)) return false;
  } else if (A$1(t5)) {
    if (!A$1(e5) || (a42 = t5, i42 = e5, !(g$1 ? a42.source === i42.source && a42.flags === i42.flags : RegExp.prototype.toString.call(a42) === RegExp.prototype.toString.call(i42)))) return false;
  } else if (_3(t5) || t5 instanceof Error) {
    if (t5.message !== e5.message || t5.name !== e5.name) return false;
  } else {
    if (x3(t5)) {
      if (n42 || !L3(t5) && !M3(t5)) {
        if (!function(t6, e6) {
          return t6.byteLength === e6.byteLength && 0 === V2(new Uint8Array(t6.buffer, t6.byteOffset, t6.byteLength), new Uint8Array(e6.buffer, e6.byteOffset, e6.byteLength));
        }(t5, e5)) return false;
      } else if (!function(t6, e6) {
        if (t6.byteLength !== e6.byteLength) return false;
        for (var n5 = 0; n5 < t6.byteLength; n5++) if (t6[n5] !== e6[n5]) return false;
        return true;
      }(t5, e5)) return false;
      var s42 = G2(t5), h5 = G2(e5);
      return s42.length === h5.length && C3(t5, e5, n42, r5, 0, s42);
    }
    if (k3(t5)) return !(!k3(e5) || t5.size !== e5.size) && C3(t5, e5, n42, r5, 2);
    if (R3(t5)) return !(!R3(e5) || t5.size !== e5.size) && C3(t5, e5, n42, r5, 3);
    if (O3(t5)) {
      if (c42 = e5, (o42 = t5).byteLength !== c42.byteLength || 0 !== V2(new Uint8Array(o42), new Uint8Array(c42))) return false;
    } else if (T3(t5) && !function(t6, e6) {
      return P$1(t6) ? P$1(e6) && b$1(Number.prototype.valueOf.call(t6), Number.prototype.valueOf.call(e6)) : I3(t6) ? I3(e6) && String.prototype.valueOf.call(t6) === String.prototype.valueOf.call(e6) : D3(t6) ? D3(e6) && Boolean.prototype.valueOf.call(t6) === Boolean.prototype.valueOf.call(e6) : F3(t6) ? F3(e6) && BigInt.prototype.valueOf.call(t6) === BigInt.prototype.valueOf.call(e6) : N$1(e6) && Symbol.prototype.valueOf.call(t6) === Symbol.prototype.valueOf.call(e6);
    }(t5, e5)) return false;
  }
  return C3(t5, e5, n42, r5, 0);
}
function z3(t5, e5) {
  return e5.filter(function(e6) {
    return w$1(t5, e6);
  });
}
function C3(t5, e5, n42, r5, o42, c42) {
  if (5 === arguments.length) {
    c42 = Object.keys(t5);
    var a42 = Object.keys(e5);
    if (c42.length !== a42.length) return false;
  }
  for (var i42 = 0; i42 < c42.length; i42++) if (!E3(e5, c42[i42])) return false;
  if (n42 && 5 === arguments.length) {
    var u42 = v$1(t5);
    if (0 !== u42.length) {
      var l42 = 0;
      for (i42 = 0; i42 < u42.length; i42++) {
        var f42 = u42[i42];
        if (w$1(t5, f42)) {
          if (!w$1(e5, f42)) return false;
          c42.push(f42), l42++;
        } else if (w$1(e5, f42)) return false;
      }
      var s42 = v$1(e5);
      if (u42.length !== s42.length && z3(e5, s42).length !== l42) return false;
    } else {
      var p42 = v$1(e5);
      if (0 !== p42.length && 0 !== z3(e5, p42).length) return false;
    }
  }
  if (0 === c42.length && (0 === o42 || 1 === o42 && 0 === t5.length || 0 === t5.size)) return true;
  if (void 0 === r5) r5 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
  else {
    var g4 = r5.val1.get(t5);
    if (void 0 !== g4) {
      var h5 = r5.val2.get(e5);
      if (void 0 !== h5) return g4 === h5;
    }
    r5.position++;
  }
  r5.val1.set(t5, r5.position), r5.val2.set(e5, r5.position);
  var y5 = Q2(t5, e5, n42, c42, r5, o42);
  return r5.val1.delete(t5), r5.val2.delete(e5), y5;
}
function Y3(t5, e5, n42, r5) {
  for (var o42 = h$12(t5), c42 = 0; c42 < o42.length; c42++) {
    var a42 = o42[c42];
    if (B3(e5, a42, n42, r5)) return t5.delete(a42), true;
  }
  return false;
}
function W2(t5) {
  switch (p$3(t5)) {
    case "undefined":
      return null;
    case "object":
      return;
    case "symbol":
      return false;
    case "string":
      t5 = +t5;
    case "number":
      if (d$12(t5)) return false;
  }
  return true;
}
function H2(t5, e5, n42) {
  var r5 = W2(n42);
  return null != r5 ? r5 : e5.has(r5) && !t5.has(r5);
}
function J2(t5, e5, n42, r5, o42) {
  var c42 = W2(n42);
  if (null != c42) return c42;
  var a42 = e5.get(c42);
  return !(void 0 === a42 && !e5.has(c42) || !B3(r5, a42, false, o42)) && (!t5.has(c42) && B3(r5, a42, false, o42));
}
function K2(t5, e5, n42, r5, o42, c42) {
  for (var a42 = h$12(t5), i42 = 0; i42 < a42.length; i42++) {
    var u42 = a42[i42];
    if (B3(n42, u42, o42, c42) && B3(r5, e5.get(u42), o42, c42)) return t5.delete(u42), true;
  }
  return false;
}
function Q2(t5, e5, n42, r5, o42, c42) {
  var a42 = 0;
  if (2 === c42) {
    if (!function(t6, e6, n5, r6) {
      for (var o5 = null, c5 = h$12(t6), a5 = 0; a5 < c5.length; a5++) {
        var i5 = c5[a5];
        if ("object" === p$3(i5) && null !== i5) null === o5 && (o5 = /* @__PURE__ */ new Set()), o5.add(i5);
        else if (!e6.has(i5)) {
          if (n5) return false;
          if (!H2(t6, e6, i5)) return false;
          null === o5 && (o5 = /* @__PURE__ */ new Set()), o5.add(i5);
        }
      }
      if (null !== o5) {
        for (var u5 = h$12(e6), l5 = 0; l5 < u5.length; l5++) {
          var f42 = u5[l5];
          if ("object" === p$3(f42) && null !== f42) {
            if (!Y3(o5, f42, n5, r6)) return false;
          } else if (!n5 && !t6.has(f42) && !Y3(o5, f42, n5, r6)) return false;
        }
        return 0 === o5.size;
      }
      return true;
    }(t5, e5, n42, o42)) return false;
  } else if (3 === c42) {
    if (!function(t6, e6, n5, r6) {
      for (var o5 = null, c5 = y$2(t6), a5 = 0; a5 < c5.length; a5++) {
        var i5 = s$3(c5[a5], 2), u5 = i5[0], l5 = i5[1];
        if ("object" === p$3(u5) && null !== u5) null === o5 && (o5 = /* @__PURE__ */ new Set()), o5.add(u5);
        else {
          var f42 = e6.get(u5);
          if (void 0 === f42 && !e6.has(u5) || !B3(l5, f42, n5, r6)) {
            if (n5) return false;
            if (!J2(t6, e6, u5, l5, r6)) return false;
            null === o5 && (o5 = /* @__PURE__ */ new Set()), o5.add(u5);
          }
        }
      }
      if (null !== o5) {
        for (var g4 = y$2(e6), h5 = 0; h5 < g4.length; h5++) {
          var b4 = s$3(g4[h5], 2), v5 = (u5 = b4[0], b4[1]);
          if ("object" === p$3(u5) && null !== u5) {
            if (!K2(o5, t6, u5, v5, n5, r6)) return false;
          } else if (!(n5 || t6.has(u5) && B3(t6.get(u5), v5, false, r6) || K2(o5, t6, u5, v5, false, r6))) return false;
        }
        return 0 === o5.size;
      }
      return true;
    }(t5, e5, n42, o42)) return false;
  } else if (1 === c42) for (; a42 < t5.length; a42++) {
    if (!E3(t5, a42)) {
      if (E3(e5, a42)) return false;
      for (var i42 = Object.keys(t5); a42 < i42.length; a42++) {
        var u42 = i42[a42];
        if (!E3(e5, u42) || !B3(t5[u42], e5[u42], n42, o42)) return false;
      }
      return i42.length === Object.keys(e5).length;
    }
    if (!E3(e5, a42) || !B3(t5[a42], e5[a42], n42, o42)) return false;
  }
  for (a42 = 0; a42 < r5.length; a42++) {
    var l42 = r5[a42];
    if (!B3(t5[l42], e5[l42], n42, o42)) return false;
  }
  return true;
}
var X2 = { isDeepEqual: function(t5, e5) {
  return B3(t5, e5, false);
}, isDeepStrictEqual: function(t5, e5) {
  return B3(t5, e5, true);
} };
var Z2 = {};
var $$1 = false;
function tt() {
  if ($$1) return Z2;
  $$1 = true;
  var o42 = T$1;
  function c42(t5) {
    return (c42 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t6) {
      return typeof t6;
    } : function(t6) {
      return t6 && "function" == typeof Symbol && t6.constructor === Symbol && t6 !== Symbol.prototype ? "symbol" : typeof t6;
    })(t5);
  }
  var a42, u42, l42 = i$5().codes, s42 = l42.ERR_AMBIGUOUS_ARGUMENT, p42 = l42.ERR_INVALID_ARG_TYPE, g4 = l42.ERR_INVALID_ARG_VALUE, h5 = l42.ERR_INVALID_RETURN_VALUE, y5 = l42.ERR_MISSING_ARGS, b4 = f$6(), v5 = X.inspect, d4 = X.types, m$13 = d4.isPromise, E4 = d4.isRegExp, w4 = Object.assign ? Object.assign : r4.assign, S4 = Object.is ? Object.is : m3;
  function j4() {
    a42 = X2.isDeepEqual, u42 = X2.isDeepStrictEqual;
  }
  var O4 = false, x4 = Z2 = k4, q3 = {};
  function R4(t5) {
    if (t5.message instanceof Error) throw t5.message;
    throw new b4(t5);
  }
  function A4(t5, e5, n42, r5) {
    if (!n42) {
      var o5 = false;
      if (0 === e5) o5 = true, r5 = "No value argument passed to \`assert.ok()\`";
      else if (r5 instanceof Error) throw r5;
      var c5 = new b4({ actual: n42, expected: true, message: r5, operator: "==", stackStartFn: t5 });
      throw c5.generatedMessage = o5, c5;
    }
  }
  function k4() {
    for (var t5 = arguments.length, e5 = new Array(t5), n42 = 0; n42 < t5; n42++) e5[n42] = arguments[n42];
    A4.apply(void 0, [k4, e5.length].concat(e5));
  }
  x4.fail = function t5(e5, n42, r5, c5, a5) {
    var i42, u5 = arguments.length;
    if (0 === u5) i42 = "Failed";
    else if (1 === u5) r5 = e5, e5 = void 0;
    else {
      if (false === O4) {
        O4 = true;
        var l5 = o42.emitWarning ? o42.emitWarning : console.warn.bind(console);
        l5("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      2 === u5 && (c5 = "!=");
    }
    if (r5 instanceof Error) throw r5;
    var f42 = { actual: e5, expected: n42, operator: void 0 === c5 ? "fail" : c5, stackStartFn: a5 || t5 };
    void 0 !== r5 && (f42.message = r5);
    var s5 = new b4(f42);
    throw i42 && (s5.message = i42, s5.generatedMessage = true), s5;
  }, x4.AssertionError = b4, x4.ok = k4, x4.equal = function t5(e5, n42, r5) {
    if (arguments.length < 2) throw new y5("actual", "expected");
    e5 != n42 && R4({ actual: e5, expected: n42, message: r5, operator: "==", stackStartFn: t5 });
  }, x4.notEqual = function t5(e5, n42, r5) {
    if (arguments.length < 2) throw new y5("actual", "expected");
    e5 == n42 && R4({ actual: e5, expected: n42, message: r5, operator: "!=", stackStartFn: t5 });
  }, x4.deepEqual = function t5(e5, n42, r5) {
    if (arguments.length < 2) throw new y5("actual", "expected");
    void 0 === a42 && j4(), a42(e5, n42) || R4({ actual: e5, expected: n42, message: r5, operator: "deepEqual", stackStartFn: t5 });
  }, x4.notDeepEqual = function t5(e5, n42, r5) {
    if (arguments.length < 2) throw new y5("actual", "expected");
    void 0 === a42 && j4(), a42(e5, n42) && R4({ actual: e5, expected: n42, message: r5, operator: "notDeepEqual", stackStartFn: t5 });
  }, x4.deepStrictEqual = function t5(e5, n42, r5) {
    if (arguments.length < 2) throw new y5("actual", "expected");
    void 0 === a42 && j4(), u42(e5, n42) || R4({ actual: e5, expected: n42, message: r5, operator: "deepStrictEqual", stackStartFn: t5 });
  }, x4.notDeepStrictEqual = function t5(e5, n42, r5) {
    if (arguments.length < 2) throw new y5("actual", "expected");
    void 0 === a42 && j4();
    u42(e5, n42) && R4({ actual: e5, expected: n42, message: r5, operator: "notDeepStrictEqual", stackStartFn: t5 });
  }, x4.strictEqual = function t5(e5, n42, r5) {
    if (arguments.length < 2) throw new y5("actual", "expected");
    S4(e5, n42) || R4({ actual: e5, expected: n42, message: r5, operator: "strictEqual", stackStartFn: t5 });
  }, x4.notStrictEqual = function t5(e5, n42, r5) {
    if (arguments.length < 2) throw new y5("actual", "expected");
    S4(e5, n42) && R4({ actual: e5, expected: n42, message: r5, operator: "notStrictEqual", stackStartFn: t5 });
  };
  var _4 = function t5(e5, n42, r5) {
    var o5 = this;
    !function(t6, e6) {
      if (!(t6 instanceof e6)) throw new TypeError("Cannot call a class as a function");
    }(this, t5), n42.forEach(function(t6) {
      t6 in e5 && (void 0 !== r5 && "string" == typeof r5[t6] && E4(e5[t6]) && e5[t6].test(r5[t6]) ? o5[t6] = r5[t6] : o5[t6] = e5[t6]);
    });
  };
  function T4(t5, e5, n42, r5, o5, c5) {
    if (!(n42 in t5) || !u42(t5[n42], e5[n42])) {
      if (!r5) {
        var a5 = new _4(t5, o5), i42 = new _4(e5, o5, t5), l5 = new b4({ actual: a5, expected: i42, operator: "deepStrictEqual", stackStartFn: c5 });
        throw l5.actual = t5, l5.expected = e5, l5.operator = c5.name, l5;
      }
      R4({ actual: t5, expected: e5, message: r5, operator: c5.name, stackStartFn: c5 });
    }
  }
  function P4(t5, e5, n42, r5) {
    if ("function" != typeof e5) {
      if (E4(e5)) return e5.test(t5);
      if (2 === arguments.length) throw new p42("expected", ["Function", "RegExp"], e5);
      if ("object" !== c42(t5) || null === t5) {
        var o5 = new b4({ actual: t5, expected: e5, message: n42, operator: "deepStrictEqual", stackStartFn: r5 });
        throw o5.operator = r5.name, o5;
      }
      var i42 = Object.keys(e5);
      if (e5 instanceof Error) i42.push("name", "message");
      else if (0 === i42.length) throw new g4("error", e5, "may not be an empty object");
      return void 0 === a42 && j4(), i42.forEach(function(o6) {
        "string" == typeof t5[o6] && E4(e5[o6]) && e5[o6].test(t5[o6]) || T4(t5, e5, o6, n42, i42, r5);
      }), true;
    }
    return void 0 !== e5.prototype && t5 instanceof e5 || !Error.isPrototypeOf(e5) && true === e5.call({}, t5);
  }
  function I4(t5) {
    if ("function" != typeof t5) throw new p42("fn", "Function", t5);
    try {
      t5();
    } catch (t6) {
      return t6;
    }
    return q3;
  }
  function D4(t5) {
    return m$13(t5) || null !== t5 && "object" === c42(t5) && "function" == typeof t5.then && "function" == typeof t5.catch;
  }
  function F4(t5) {
    return Promise.resolve().then(function() {
      var e5;
      if ("function" == typeof t5) {
        if (!D4(e5 = t5())) throw new h5("instance of Promise", "promiseFn", e5);
      } else {
        if (!D4(t5)) throw new p42("promiseFn", ["Function", "Promise"], t5);
        e5 = t5;
      }
      return Promise.resolve().then(function() {
        return e5;
      }).then(function() {
        return q3;
      }).catch(function(t6) {
        return t6;
      });
    });
  }
  function N4(t5, e5, n42, r5) {
    if ("string" == typeof n42) {
      if (4 === arguments.length) throw new p42("error", ["Object", "Error", "Function", "RegExp"], n42);
      if ("object" === c42(e5) && null !== e5) {
        if (e5.message === n42) throw new s42("error/message", 'The error message "'.concat(e5.message, '" is identical to the message.'));
      } else if (e5 === n42) throw new s42("error/message", 'The error "'.concat(e5, '" is identical to the message.'));
      r5 = n42, n42 = void 0;
    } else if (null != n42 && "object" !== c42(n42) && "function" != typeof n42) throw new p42("error", ["Object", "Error", "Function", "RegExp"], n42);
    if (e5 === q3) {
      var o5 = "";
      n42 && n42.name && (o5 += " (".concat(n42.name, ")")), o5 += r5 ? ": ".concat(r5) : ".";
      var a5 = "rejects" === t5.name ? "rejection" : "exception";
      R4({ actual: void 0, expected: n42, operator: t5.name, message: "Missing expected ".concat(a5).concat(o5), stackStartFn: t5 });
    }
    if (n42 && !P4(e5, n42, r5, t5)) throw e5;
  }
  function L4(t5, e5, n42, r5) {
    if (e5 !== q3) {
      if ("string" == typeof n42 && (r5 = n42, n42 = void 0), !n42 || P4(e5, n42)) {
        var o5 = r5 ? ": ".concat(r5) : ".", c5 = "doesNotReject" === t5.name ? "rejection" : "exception";
        R4({ actual: e5, expected: n42, operator: t5.name, message: "Got unwanted ".concat(c5).concat(o5, "\\n") + 'Actual message: "'.concat(e5 && e5.message, '"'), stackStartFn: t5 });
      }
      throw e5;
    }
  }
  function M4() {
    for (var t5 = arguments.length, e5 = new Array(t5), n42 = 0; n42 < t5; n42++) e5[n42] = arguments[n42];
    A4.apply(void 0, [M4, e5.length].concat(e5));
  }
  return x4.throws = function t5(e5) {
    for (var n42 = arguments.length, r5 = new Array(n42 > 1 ? n42 - 1 : 0), o5 = 1; o5 < n42; o5++) r5[o5 - 1] = arguments[o5];
    N4.apply(void 0, [t5, I4(e5)].concat(r5));
  }, x4.rejects = function t5(e5) {
    for (var n42 = arguments.length, r5 = new Array(n42 > 1 ? n42 - 1 : 0), o5 = 1; o5 < n42; o5++) r5[o5 - 1] = arguments[o5];
    return F4(e5).then(function(e6) {
      return N4.apply(void 0, [t5, e6].concat(r5));
    });
  }, x4.doesNotThrow = function t5(e5) {
    for (var n42 = arguments.length, r5 = new Array(n42 > 1 ? n42 - 1 : 0), o5 = 1; o5 < n42; o5++) r5[o5 - 1] = arguments[o5];
    L4.apply(void 0, [t5, I4(e5)].concat(r5));
  }, x4.doesNotReject = function t5(e5) {
    for (var n42 = arguments.length, r5 = new Array(n42 > 1 ? n42 - 1 : 0), o5 = 1; o5 < n42; o5++) r5[o5 - 1] = arguments[o5];
    return F4(e5).then(function(e6) {
      return L4.apply(void 0, [t5, e6].concat(r5));
    });
  }, x4.ifError = function t5(e5) {
    if (null != e5) {
      var n42 = "ifError got unwanted exception: ";
      "object" === c42(e5) && "string" == typeof e5.message ? 0 === e5.message.length && e5.constructor ? n42 += e5.constructor.name : n42 += e5.message : n42 += v5(e5);
      var r5 = new b4({ actual: e5, expected: null, operator: "ifError", message: n42, stackStartFn: t5 }), o5 = e5.stack;
      if ("string" == typeof o5) {
        var a5 = o5.split("\\n");
        a5.shift();
        for (var i42 = r5.stack.split("\\n"), u5 = 0; u5 < a5.length; u5++) {
          var l5 = i42.indexOf(a5[u5]);
          if (-1 !== l5) {
            i42 = i42.slice(0, l5);
            break;
          }
        }
        r5.stack = "".concat(i42.join("\\n"), "\\n").concat(a5.join("\\n"));
      }
      throw r5;
    }
  }, x4.strict = w4(M4, x4, { equal: x4.strictEqual, deepEqual: x4.deepStrictEqual, notEqual: x4.notStrictEqual, notDeepEqual: x4.notDeepStrictEqual }), x4.strict.strict = x4.strict, Z2;
}
var et = tt();
et.AssertionError;
et.deepEqual;
et.deepStrictEqual;
et.doesNotReject;
et.doesNotThrow;
et.equal;
et.fail;
et.ifError;
et.notDeepEqual;
et.notDeepStrictEqual;
et.notEqual;
et.notStrictEqual;
et.ok;
et.rejects;
et.strict;
et.strictEqual;
et.throws;
et.AssertionError;
et.deepEqual;
et.deepStrictEqual;
et.doesNotReject;
et.doesNotThrow;
et.equal;
et.fail;
et.ifError;
et.notDeepEqual;
et.notDeepStrictEqual;
et.notEqual;
et.notStrictEqual;
et.ok;
et.rejects;
et.strict;
et.strictEqual;
et.throws;
et.AssertionError;
et.deepEqual;
et.deepStrictEqual;
et.doesNotReject;
et.doesNotThrow;
et.equal;
et.fail;
et.ifError;
et.notDeepEqual;
et.notDeepStrictEqual;
et.notEqual;
et.notStrictEqual;
et.ok;
et.rejects;
et.strict;
et.strictEqual;
et.throws;
function unimplemented(name2) {
  throw new Error("Node.js process " + name2 + " is not supported by JSPM core outside of Node.js");
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue)
    return;
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length)
    drainQueue();
}
function drainQueue() {
  if (draining)
    return;
  var timeout = setTimeout(cleanUpNextTick, 0);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue)
        currentQueue[queueIndex].run();
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  clearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i42 = 1; i42 < arguments.length; i42++)
      args[i42 - 1] = arguments[i42];
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining)
    setTimeout(drainQueue, 0);
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var arch = "x64";
var platform = "browser";
var env = {
  PATH: "/usr/bin",
  LANG: navigator.language + ".UTF-8",
  PWD: "/",
  HOME: "/home",
  TMP: "/tmp"
};
var argv = ["/usr/bin/node"];
var execArgv = [];
var version = "v16.8.0";
var versions = {};
var emitWarning = function(message, type) {
  console.warn((type ? type + ": " : "") + message);
};
var binding = function(name2) {
  unimplemented("binding");
};
var umask = function(mask) {
  return 0;
};
var cwd = function() {
  return "/";
};
var chdir = function(dir) {
};
var release = {
  name: "node",
  sourceUrl: "",
  headersUrl: "",
  libUrl: ""
};
function noop() {
}
var _rawDebug = noop;
var moduleLoadList = [];
function _linkedBinding(name2) {
  unimplemented("_linkedBinding");
}
var domain = {};
var _exiting = false;
var config = {};
function dlopen(name2) {
  unimplemented("dlopen");
}
function _getActiveRequests() {
  return [];
}
function _getActiveHandles() {
  return [];
}
var reallyExit = noop;
var _kill = noop;
var cpuUsage = function() {
  return {};
};
var resourceUsage = cpuUsage;
var memoryUsage = cpuUsage;
var kill = noop;
var exit = noop;
var openStdin = noop;
var allowedNodeEnvironmentFlags = {};
function assert(condition, message) {
  if (!condition) throw new Error(message || "assertion error");
}
var features = {
  inspector: false,
  debug: false,
  uv: false,
  ipv6: false,
  tls_alpn: false,
  tls_sni: false,
  tls_ocsp: false,
  tls: false,
  cached_builtins: true
};
var _fatalExceptions = noop;
var setUncaughtExceptionCaptureCallback = noop;
function hasUncaughtExceptionCaptureCallback() {
  return false;
}
var _tickCallback = noop;
var _debugProcess = noop;
var _debugEnd = noop;
var _startProfilerIdleNotifier = noop;
var _stopProfilerIdleNotifier = noop;
var stdout = void 0;
var stderr = void 0;
var stdin = void 0;
var abort = noop;
var pid = 2;
var ppid = 1;
var execPath = "/bin/usr/node";
var debugPort = 9229;
var argv0 = "node";
var _preload_modules = [];
var setSourceMapsEnabled = noop;
var _performance = {
  now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
  timing: typeof performance !== "undefined" ? performance.timing : void 0
};
if (_performance.now === void 0) {
  nowOffset = Date.now();
  if (_performance.timing && _performance.timing.navigationStart) {
    nowOffset = _performance.timing.navigationStart;
  }
  _performance.now = () => Date.now() - nowOffset;
}
var nowOffset;
function uptime() {
  return _performance.now() / 1e3;
}
var nanoPerSec = 1e9;
function hrtime(previousTimestamp) {
  var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
  var clocktime = _performance.now() * 1e-3;
  var seconds = Math.floor(clocktime) + baseNow;
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += nanoPerSec;
    }
  }
  return [seconds, nanoseconds];
}
hrtime.bigint = function(time) {
  var diff = hrtime(time);
  if (typeof BigInt === "undefined") {
    return diff[0] * nanoPerSec + diff[1];
  }
  return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
};
var _maxListeners = 10;
var _events = {};
var _eventsCount = 0;
function on() {
  return process2;
}
var addListener = on;
var once = on;
var off = on;
var removeListener = on;
var removeAllListeners = on;
var emit = noop;
var prependListener = on;
var prependOnceListener = on;
function listeners(name2) {
  return [];
}
var process2 = {
  version,
  versions,
  arch,
  platform,
  release,
  _rawDebug,
  moduleLoadList,
  binding,
  _linkedBinding,
  _events,
  _eventsCount,
  _maxListeners,
  on,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  prependListener,
  prependOnceListener,
  listeners,
  domain,
  _exiting,
  config,
  dlopen,
  uptime,
  _getActiveRequests,
  _getActiveHandles,
  reallyExit,
  _kill,
  cpuUsage,
  resourceUsage,
  memoryUsage,
  kill,
  exit,
  openStdin,
  allowedNodeEnvironmentFlags,
  assert,
  features,
  _fatalExceptions,
  setUncaughtExceptionCaptureCallback,
  hasUncaughtExceptionCaptureCallback,
  emitWarning,
  nextTick,
  _tickCallback,
  _debugProcess,
  _debugEnd,
  _startProfilerIdleNotifier,
  _stopProfilerIdleNotifier,
  stdout,
  stdin,
  stderr,
  abort,
  umask,
  chdir,
  cwd,
  env,
  title,
  argv,
  execArgv,
  pid,
  ppid,
  execPath,
  debugPort,
  hrtime,
  argv0,
  _preload_modules,
  setSourceMapsEnabled
};
var exports$d2 = {};
var _dewExec$c2 = false;
function dew$c2() {
  if (_dewExec$c2) return exports$d2;
  _dewExec$c2 = true;
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  exports$d2 = ZStream;
  return exports$d2;
}
var exports$c2 = {};
var _dewExec$b2 = false;
function dew$b2() {
  if (_dewExec$b2) return exports$c2;
  _dewExec$b2 = true;
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports$c2.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p42 in source) {
        if (_has(source, p42)) {
          obj[p42] = source[p42];
        }
      }
    }
    return obj;
  };
  exports$c2.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i42 = 0; i42 < len; i42++) {
        dest[dest_offs + i42] = src[src_offs + i42];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      var i42, l42, len, pos, chunk, result;
      len = 0;
      for (i42 = 0, l42 = chunks.length; i42 < l42; i42++) {
        len += chunks[i42].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i42 = 0, l42 = chunks.length; i42 < l42; i42++) {
        chunk = chunks[i42];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i42 = 0; i42 < len; i42++) {
        dest[dest_offs + i42] = src[src_offs + i42];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports$c2.setTyped = function(on2) {
    if (on2) {
      exports$c2.Buf8 = Uint8Array;
      exports$c2.Buf16 = Uint16Array;
      exports$c2.Buf32 = Int32Array;
      exports$c2.assign(exports$c2, fnTyped);
    } else {
      exports$c2.Buf8 = Array;
      exports$c2.Buf16 = Array;
      exports$c2.Buf32 = Array;
      exports$c2.assign(exports$c2, fnUntyped);
    }
  };
  exports$c2.setTyped(TYPED_OK);
  return exports$c2;
}
var exports$b2 = {};
var _dewExec$a2 = false;
function dew$a2() {
  if (_dewExec$a2) return exports$b2;
  _dewExec$a2 = true;
  var utils = dew$b2();
  var Z_FIXED2 = 4;
  var Z_BINARY2 = 0;
  var Z_TEXT2 = 1;
  var Z_UNKNOWN2 = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  );
  var extra_dbits = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  );
  var extra_blbits = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  );
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist) {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  }
  function put_short(s42, w4) {
    s42.pending_buf[s42.pending++] = w4 & 255;
    s42.pending_buf[s42.pending++] = w4 >>> 8 & 255;
  }
  function send_bits(s42, value, length) {
    if (s42.bi_valid > Buf_size - length) {
      s42.bi_buf |= value << s42.bi_valid & 65535;
      put_short(s42, s42.bi_buf);
      s42.bi_buf = value >> Buf_size - s42.bi_valid;
      s42.bi_valid += length - Buf_size;
    } else {
      s42.bi_buf |= value << s42.bi_valid & 65535;
      s42.bi_valid += length;
    }
  }
  function send_code(s42, c42, tree) {
    send_bits(
      s42,
      tree[c42 * 2],
      tree[c42 * 2 + 1]
      /*.Len*/
    );
  }
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush(s42) {
    if (s42.bi_valid === 16) {
      put_short(s42, s42.bi_buf);
      s42.bi_buf = 0;
      s42.bi_valid = 0;
    } else if (s42.bi_valid >= 8) {
      s42.pending_buf[s42.pending++] = s42.bi_buf & 255;
      s42.bi_buf >>= 8;
      s42.bi_valid -= 8;
    }
  }
  function gen_bitlen(s42, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h5;
    var n42, m4;
    var bits;
    var xbits;
    var f42;
    var overflow = 0;
    for (bits = 0; bits <= MAX_BITS; bits++) {
      s42.bl_count[bits] = 0;
    }
    tree[s42.heap[s42.heap_max] * 2 + 1] = 0;
    for (h5 = s42.heap_max + 1; h5 < HEAP_SIZE; h5++) {
      n42 = s42.heap[h5];
      bits = tree[tree[n42 * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n42 * 2 + 1] = bits;
      if (n42 > max_code) {
        continue;
      }
      s42.bl_count[bits]++;
      xbits = 0;
      if (n42 >= base) {
        xbits = extra[n42 - base];
      }
      f42 = tree[n42 * 2];
      s42.opt_len += f42 * (bits + xbits);
      if (has_stree) {
        s42.static_len += f42 * (stree[n42 * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s42.bl_count[bits] === 0) {
        bits--;
      }
      s42.bl_count[bits]--;
      s42.bl_count[bits + 1] += 2;
      s42.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n42 = s42.bl_count[bits];
      while (n42 !== 0) {
        m4 = s42.heap[--h5];
        if (m4 > max_code) {
          continue;
        }
        if (tree[m4 * 2 + 1] !== bits) {
          s42.opt_len += (bits - tree[m4 * 2 + 1]) * tree[m4 * 2];
          tree[m4 * 2 + 1] = bits;
        }
        n42--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n42;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n42 = 0; n42 <= max_code; n42++) {
      var len = tree[n42 * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n42 * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  function tr_static_init() {
    var n42;
    var bits;
    var length;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n42 = 0; n42 < 1 << extra_lbits[code]; n42++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist;
      for (n42 = 0; n42 < 1 << extra_dbits[code]; n42++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < D_CODES; code++) {
      base_dist[code] = dist << 7;
      for (n42 = 0; n42 < 1 << extra_dbits[code] - 7; n42++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n42 = 0;
    while (n42 <= 143) {
      static_ltree[n42 * 2 + 1] = 8;
      n42++;
      bl_count[8]++;
    }
    while (n42 <= 255) {
      static_ltree[n42 * 2 + 1] = 9;
      n42++;
      bl_count[9]++;
    }
    while (n42 <= 279) {
      static_ltree[n42 * 2 + 1] = 7;
      n42++;
      bl_count[7]++;
    }
    while (n42 <= 287) {
      static_ltree[n42 * 2 + 1] = 8;
      n42++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n42 = 0; n42 < D_CODES; n42++) {
      static_dtree[n42 * 2 + 1] = 5;
      static_dtree[n42 * 2] = bi_reverse(n42, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s42) {
    var n42;
    for (n42 = 0; n42 < L_CODES; n42++) {
      s42.dyn_ltree[n42 * 2] = 0;
    }
    for (n42 = 0; n42 < D_CODES; n42++) {
      s42.dyn_dtree[n42 * 2] = 0;
    }
    for (n42 = 0; n42 < BL_CODES; n42++) {
      s42.bl_tree[n42 * 2] = 0;
    }
    s42.dyn_ltree[END_BLOCK * 2] = 1;
    s42.opt_len = s42.static_len = 0;
    s42.last_lit = s42.matches = 0;
  }
  function bi_windup(s42) {
    if (s42.bi_valid > 8) {
      put_short(s42, s42.bi_buf);
    } else if (s42.bi_valid > 0) {
      s42.pending_buf[s42.pending++] = s42.bi_buf;
    }
    s42.bi_buf = 0;
    s42.bi_valid = 0;
  }
  function copy_block(s42, buf, len, header) {
    bi_windup(s42);
    {
      put_short(s42, len);
      put_short(s42, ~len);
    }
    utils.arraySet(s42.pending_buf, s42.window, buf, len, s42.pending);
    s42.pending += len;
  }
  function smaller(tree, n42, m4, depth) {
    var _n2 = n42 * 2;
    var _m2 = m4 * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n42] <= depth[m4];
  }
  function pqdownheap(s42, tree, k4) {
    var v5 = s42.heap[k4];
    var j4 = k4 << 1;
    while (j4 <= s42.heap_len) {
      if (j4 < s42.heap_len && smaller(tree, s42.heap[j4 + 1], s42.heap[j4], s42.depth)) {
        j4++;
      }
      if (smaller(tree, v5, s42.heap[j4], s42.depth)) {
        break;
      }
      s42.heap[k4] = s42.heap[j4];
      k4 = j4;
      j4 <<= 1;
    }
    s42.heap[k4] = v5;
  }
  function compress_block(s42, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s42.last_lit !== 0) {
      do {
        dist = s42.pending_buf[s42.d_buf + lx * 2] << 8 | s42.pending_buf[s42.d_buf + lx * 2 + 1];
        lc = s42.pending_buf[s42.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code(s42, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s42, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s42, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s42, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s42, dist, extra);
          }
        }
      } while (lx < s42.last_lit);
    }
    send_code(s42, END_BLOCK, ltree);
  }
  function build_tree(s42, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n42, m4;
    var max_code = -1;
    var node;
    s42.heap_len = 0;
    s42.heap_max = HEAP_SIZE;
    for (n42 = 0; n42 < elems; n42++) {
      if (tree[n42 * 2] !== 0) {
        s42.heap[++s42.heap_len] = max_code = n42;
        s42.depth[n42] = 0;
      } else {
        tree[n42 * 2 + 1] = 0;
      }
    }
    while (s42.heap_len < 2) {
      node = s42.heap[++s42.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s42.depth[node] = 0;
      s42.opt_len--;
      if (has_stree) {
        s42.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n42 = s42.heap_len >> 1; n42 >= 1; n42--) {
      pqdownheap(s42, tree, n42);
    }
    node = elems;
    do {
      n42 = s42.heap[
        1
        /*SMALLEST*/
      ];
      s42.heap[
        1
        /*SMALLEST*/
      ] = s42.heap[s42.heap_len--];
      pqdownheap(
        s42,
        tree,
        1
        /*SMALLEST*/
      );
      m4 = s42.heap[
        1
        /*SMALLEST*/
      ];
      s42.heap[--s42.heap_max] = n42;
      s42.heap[--s42.heap_max] = m4;
      tree[node * 2] = tree[n42 * 2] + tree[m4 * 2];
      s42.depth[node] = (s42.depth[n42] >= s42.depth[m4] ? s42.depth[n42] : s42.depth[m4]) + 1;
      tree[n42 * 2 + 1] = tree[m4 * 2 + 1] = node;
      s42.heap[
        1
        /*SMALLEST*/
      ] = node++;
      pqdownheap(
        s42,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s42.heap_len >= 2);
    s42.heap[--s42.heap_max] = s42.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s42, desc);
    gen_codes(tree, max_code, s42.bl_count);
  }
  function scan_tree(s42, tree, max_code) {
    var n42;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n42 = 0; n42 <= max_code; n42++) {
      curlen = nextlen;
      nextlen = tree[(n42 + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s42.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s42.bl_tree[curlen * 2]++;
        }
        s42.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s42.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s42.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s42, tree, max_code) {
    var n42;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n42 = 0; n42 <= max_code; n42++) {
      curlen = nextlen;
      nextlen = tree[(n42 + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s42, curlen, s42.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s42, curlen, s42.bl_tree);
          count--;
        }
        send_code(s42, REP_3_6, s42.bl_tree);
        send_bits(s42, count - 3, 2);
      } else if (count <= 10) {
        send_code(s42, REPZ_3_10, s42.bl_tree);
        send_bits(s42, count - 3, 3);
      } else {
        send_code(s42, REPZ_11_138, s42.bl_tree);
        send_bits(s42, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s42) {
    var max_blindex;
    scan_tree(s42, s42.dyn_ltree, s42.l_desc.max_code);
    scan_tree(s42, s42.dyn_dtree, s42.d_desc.max_code);
    build_tree(s42, s42.bl_desc);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s42.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s42.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s42, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s42, lcodes - 257, 5);
    send_bits(s42, dcodes - 1, 5);
    send_bits(s42, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(s42, s42.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s42, s42.dyn_ltree, lcodes - 1);
    send_tree(s42, s42.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s42) {
    var black_mask = 4093624447;
    var n42;
    for (n42 = 0; n42 <= 31; n42++, black_mask >>>= 1) {
      if (black_mask & 1 && s42.dyn_ltree[n42 * 2] !== 0) {
        return Z_BINARY2;
      }
    }
    if (s42.dyn_ltree[9 * 2] !== 0 || s42.dyn_ltree[10 * 2] !== 0 || s42.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT2;
    }
    for (n42 = 32; n42 < LITERALS; n42++) {
      if (s42.dyn_ltree[n42 * 2] !== 0) {
        return Z_TEXT2;
      }
    }
    return Z_BINARY2;
  }
  var static_init_done = false;
  function _tr_init(s42) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s42.l_desc = new TreeDesc(s42.dyn_ltree, static_l_desc);
    s42.d_desc = new TreeDesc(s42.dyn_dtree, static_d_desc);
    s42.bl_desc = new TreeDesc(s42.bl_tree, static_bl_desc);
    s42.bi_buf = 0;
    s42.bi_valid = 0;
    init_block(s42);
  }
  function _tr_stored_block(s42, buf, stored_len, last) {
    send_bits(s42, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s42, buf, stored_len);
  }
  function _tr_align(s42) {
    send_bits(s42, STATIC_TREES << 1, 3);
    send_code(s42, END_BLOCK, static_ltree);
    bi_flush(s42);
  }
  function _tr_flush_block(s42, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s42.level > 0) {
      if (s42.strm.data_type === Z_UNKNOWN2) {
        s42.strm.data_type = detect_data_type(s42);
      }
      build_tree(s42, s42.l_desc);
      build_tree(s42, s42.d_desc);
      max_blindex = build_bl_tree(s42);
      opt_lenb = s42.opt_len + 3 + 7 >>> 3;
      static_lenb = s42.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s42, buf, stored_len, last);
    } else if (s42.strategy === Z_FIXED2 || static_lenb === opt_lenb) {
      send_bits(s42, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s42, static_ltree, static_dtree);
    } else {
      send_bits(s42, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s42, s42.l_desc.max_code + 1, s42.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s42, s42.dyn_ltree, s42.dyn_dtree);
    }
    init_block(s42);
    if (last) {
      bi_windup(s42);
    }
  }
  function _tr_tally(s42, dist, lc) {
    s42.pending_buf[s42.d_buf + s42.last_lit * 2] = dist >>> 8 & 255;
    s42.pending_buf[s42.d_buf + s42.last_lit * 2 + 1] = dist & 255;
    s42.pending_buf[s42.l_buf + s42.last_lit] = lc & 255;
    s42.last_lit++;
    if (dist === 0) {
      s42.dyn_ltree[lc * 2]++;
    } else {
      s42.matches++;
      dist--;
      s42.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s42.dyn_dtree[d_code(dist) * 2]++;
    }
    return s42.last_lit === s42.lit_bufsize - 1;
  }
  exports$b2._tr_init = _tr_init;
  exports$b2._tr_stored_block = _tr_stored_block;
  exports$b2._tr_flush_block = _tr_flush_block;
  exports$b2._tr_tally = _tr_tally;
  exports$b2._tr_align = _tr_align;
  return exports$b2;
}
var exports$a2 = {};
var _dewExec$92 = false;
function dew$92() {
  if (_dewExec$92) return exports$a2;
  _dewExec$92 = true;
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s22 = adler >>> 16 & 65535 | 0, n42 = 0;
    while (len !== 0) {
      n42 = len > 2e3 ? 2e3 : len;
      len -= n42;
      do {
        s1 = s1 + buf[pos++] | 0;
        s22 = s22 + s1 | 0;
      } while (--n42);
      s1 %= 65521;
      s22 %= 65521;
    }
    return s1 | s22 << 16 | 0;
  }
  exports$a2 = adler32;
  return exports$a2;
}
var exports$92 = {};
var _dewExec$82 = false;
function dew$82() {
  if (_dewExec$82) return exports$92;
  _dewExec$82 = true;
  function makeTable() {
    var c42, table = [];
    for (var n42 = 0; n42 < 256; n42++) {
      c42 = n42;
      for (var k4 = 0; k4 < 8; k4++) {
        c42 = c42 & 1 ? 3988292384 ^ c42 >>> 1 : c42 >>> 1;
      }
      table[n42] = c42;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t5 = crcTable, end = pos + len;
    crc ^= -1;
    for (var i42 = pos; i42 < end; i42++) {
      crc = crc >>> 8 ^ t5[(crc ^ buf[i42]) & 255];
    }
    return crc ^ -1;
  }
  exports$92 = crc32;
  return exports$92;
}
var exports$82 = {};
var _dewExec$72 = false;
function dew$72() {
  if (_dewExec$72) return exports$82;
  _dewExec$72 = true;
  exports$82 = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  return exports$82;
}
var exports$72 = {};
var _dewExec$62 = false;
function dew$62() {
  if (_dewExec$62) return exports$72;
  _dewExec$62 = true;
  var utils = dew$b2();
  var trees = dew$a2();
  var adler32 = dew$92();
  var crc32 = dew$82();
  var msg = dew$72();
  var Z_NO_FLUSH2 = 0;
  var Z_PARTIAL_FLUSH2 = 1;
  var Z_FULL_FLUSH2 = 3;
  var Z_FINISH2 = 4;
  var Z_BLOCK2 = 5;
  var Z_OK2 = 0;
  var Z_STREAM_END2 = 1;
  var Z_STREAM_ERROR2 = -2;
  var Z_DATA_ERROR2 = -3;
  var Z_BUF_ERROR2 = -5;
  var Z_DEFAULT_COMPRESSION2 = -1;
  var Z_FILTERED2 = 1;
  var Z_HUFFMAN_ONLY2 = 2;
  var Z_RLE2 = 3;
  var Z_FIXED2 = 4;
  var Z_DEFAULT_STRATEGY2 = 0;
  var Z_UNKNOWN2 = 2;
  var Z_DEFLATED2 = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f42) {
    return (f42 << 1) - (f42 > 4 ? 9 : 0);
  }
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending(strm) {
    var s42 = strm.state;
    var len = s42.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils.arraySet(strm.output, s42.pending_buf, s42.pending_out, len, strm.next_out);
    strm.next_out += len;
    s42.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s42.pending -= len;
    if (s42.pending === 0) {
      s42.pending_out = 0;
    }
  }
  function flush_block_only(s42, last) {
    trees._tr_flush_block(s42, s42.block_start >= 0 ? s42.block_start : -1, s42.strstart - s42.block_start, last);
    s42.block_start = s42.strstart;
    flush_pending(s42.strm);
  }
  function put_byte(s42, b4) {
    s42.pending_buf[s42.pending++] = b4;
  }
  function putShortMSB(s42, b4) {
    s42.pending_buf[s42.pending++] = b4 >>> 8 & 255;
    s42.pending_buf[s42.pending++] = b4 & 255;
  }
  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match(s42, cur_match) {
    var chain_length = s42.max_chain_length;
    var scan = s42.strstart;
    var match;
    var len;
    var best_len = s42.prev_length;
    var nice_match = s42.nice_match;
    var limit = s42.strstart > s42.w_size - MIN_LOOKAHEAD ? s42.strstart - (s42.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s42.window;
    var wmask = s42.w_mask;
    var prev = s42.prev;
    var strend = s42.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s42.prev_length >= s42.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s42.lookahead) {
      nice_match = s42.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s42.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s42.lookahead) {
      return best_len;
    }
    return s42.lookahead;
  }
  function fill_window(s42) {
    var _w_size = s42.w_size;
    var p42, n42, m4, more, str;
    do {
      more = s42.window_size - s42.lookahead - s42.strstart;
      if (s42.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils.arraySet(s42.window, s42.window, _w_size, _w_size, 0);
        s42.match_start -= _w_size;
        s42.strstart -= _w_size;
        s42.block_start -= _w_size;
        n42 = s42.hash_size;
        p42 = n42;
        do {
          m4 = s42.head[--p42];
          s42.head[p42] = m4 >= _w_size ? m4 - _w_size : 0;
        } while (--n42);
        n42 = _w_size;
        p42 = n42;
        do {
          m4 = s42.prev[--p42];
          s42.prev[p42] = m4 >= _w_size ? m4 - _w_size : 0;
        } while (--n42);
        more += _w_size;
      }
      if (s42.strm.avail_in === 0) {
        break;
      }
      n42 = read_buf(s42.strm, s42.window, s42.strstart + s42.lookahead, more);
      s42.lookahead += n42;
      if (s42.lookahead + s42.insert >= MIN_MATCH) {
        str = s42.strstart - s42.insert;
        s42.ins_h = s42.window[str];
        s42.ins_h = (s42.ins_h << s42.hash_shift ^ s42.window[str + 1]) & s42.hash_mask;
        while (s42.insert) {
          s42.ins_h = (s42.ins_h << s42.hash_shift ^ s42.window[str + MIN_MATCH - 1]) & s42.hash_mask;
          s42.prev[str & s42.w_mask] = s42.head[s42.ins_h];
          s42.head[s42.ins_h] = str;
          str++;
          s42.insert--;
          if (s42.lookahead + s42.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s42.lookahead < MIN_LOOKAHEAD && s42.strm.avail_in !== 0);
  }
  function deflate_stored(s42, flush) {
    var max_block_size = 65535;
    if (max_block_size > s42.pending_buf_size - 5) {
      max_block_size = s42.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s42.lookahead <= 1) {
        fill_window(s42);
        if (s42.lookahead === 0 && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s42.lookahead === 0) {
          break;
        }
      }
      s42.strstart += s42.lookahead;
      s42.lookahead = 0;
      var max_start = s42.block_start + max_block_size;
      if (s42.strstart === 0 || s42.strstart >= max_start) {
        s42.lookahead = s42.strstart - max_start;
        s42.strstart = max_start;
        flush_block_only(s42, false);
        if (s42.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s42.strstart - s42.block_start >= s42.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s42, false);
        if (s42.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s42.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only(s42, true);
      if (s42.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s42.strstart > s42.block_start) {
      flush_block_only(s42, false);
      if (s42.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s42, flush) {
    var hash_head;
    var bflush;
    for (; ; ) {
      if (s42.lookahead < MIN_LOOKAHEAD) {
        fill_window(s42);
        if (s42.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s42.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s42.lookahead >= MIN_MATCH) {
        s42.ins_h = (s42.ins_h << s42.hash_shift ^ s42.window[s42.strstart + MIN_MATCH - 1]) & s42.hash_mask;
        hash_head = s42.prev[s42.strstart & s42.w_mask] = s42.head[s42.ins_h];
        s42.head[s42.ins_h] = s42.strstart;
      }
      if (hash_head !== 0 && s42.strstart - hash_head <= s42.w_size - MIN_LOOKAHEAD) {
        s42.match_length = longest_match(s42, hash_head);
      }
      if (s42.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s42, s42.strstart - s42.match_start, s42.match_length - MIN_MATCH);
        s42.lookahead -= s42.match_length;
        if (s42.match_length <= s42.max_lazy_match && s42.lookahead >= MIN_MATCH) {
          s42.match_length--;
          do {
            s42.strstart++;
            s42.ins_h = (s42.ins_h << s42.hash_shift ^ s42.window[s42.strstart + MIN_MATCH - 1]) & s42.hash_mask;
            hash_head = s42.prev[s42.strstart & s42.w_mask] = s42.head[s42.ins_h];
            s42.head[s42.ins_h] = s42.strstart;
          } while (--s42.match_length !== 0);
          s42.strstart++;
        } else {
          s42.strstart += s42.match_length;
          s42.match_length = 0;
          s42.ins_h = s42.window[s42.strstart];
          s42.ins_h = (s42.ins_h << s42.hash_shift ^ s42.window[s42.strstart + 1]) & s42.hash_mask;
        }
      } else {
        bflush = trees._tr_tally(s42, 0, s42.window[s42.strstart]);
        s42.lookahead--;
        s42.strstart++;
      }
      if (bflush) {
        flush_block_only(s42, false);
        if (s42.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s42.insert = s42.strstart < MIN_MATCH - 1 ? s42.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH2) {
      flush_block_only(s42, true);
      if (s42.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s42.last_lit) {
      flush_block_only(s42, false);
      if (s42.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s42, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (; ; ) {
      if (s42.lookahead < MIN_LOOKAHEAD) {
        fill_window(s42);
        if (s42.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s42.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s42.lookahead >= MIN_MATCH) {
        s42.ins_h = (s42.ins_h << s42.hash_shift ^ s42.window[s42.strstart + MIN_MATCH - 1]) & s42.hash_mask;
        hash_head = s42.prev[s42.strstart & s42.w_mask] = s42.head[s42.ins_h];
        s42.head[s42.ins_h] = s42.strstart;
      }
      s42.prev_length = s42.match_length;
      s42.prev_match = s42.match_start;
      s42.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s42.prev_length < s42.max_lazy_match && s42.strstart - hash_head <= s42.w_size - MIN_LOOKAHEAD) {
        s42.match_length = longest_match(s42, hash_head);
        if (s42.match_length <= 5 && (s42.strategy === Z_FILTERED2 || s42.match_length === MIN_MATCH && s42.strstart - s42.match_start > 4096)) {
          s42.match_length = MIN_MATCH - 1;
        }
      }
      if (s42.prev_length >= MIN_MATCH && s42.match_length <= s42.prev_length) {
        max_insert = s42.strstart + s42.lookahead - MIN_MATCH;
        bflush = trees._tr_tally(s42, s42.strstart - 1 - s42.prev_match, s42.prev_length - MIN_MATCH);
        s42.lookahead -= s42.prev_length - 1;
        s42.prev_length -= 2;
        do {
          if (++s42.strstart <= max_insert) {
            s42.ins_h = (s42.ins_h << s42.hash_shift ^ s42.window[s42.strstart + MIN_MATCH - 1]) & s42.hash_mask;
            hash_head = s42.prev[s42.strstart & s42.w_mask] = s42.head[s42.ins_h];
            s42.head[s42.ins_h] = s42.strstart;
          }
        } while (--s42.prev_length !== 0);
        s42.match_available = 0;
        s42.match_length = MIN_MATCH - 1;
        s42.strstart++;
        if (bflush) {
          flush_block_only(s42, false);
          if (s42.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s42.match_available) {
        bflush = trees._tr_tally(s42, 0, s42.window[s42.strstart - 1]);
        if (bflush) {
          flush_block_only(s42, false);
        }
        s42.strstart++;
        s42.lookahead--;
        if (s42.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s42.match_available = 1;
        s42.strstart++;
        s42.lookahead--;
      }
    }
    if (s42.match_available) {
      bflush = trees._tr_tally(s42, 0, s42.window[s42.strstart - 1]);
      s42.match_available = 0;
    }
    s42.insert = s42.strstart < MIN_MATCH - 1 ? s42.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH2) {
      flush_block_only(s42, true);
      if (s42.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s42.last_lit) {
      flush_block_only(s42, false);
      if (s42.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s42, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s42.window;
    for (; ; ) {
      if (s42.lookahead <= MAX_MATCH) {
        fill_window(s42);
        if (s42.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE;
        }
        if (s42.lookahead === 0) {
          break;
        }
      }
      s42.match_length = 0;
      if (s42.lookahead >= MIN_MATCH && s42.strstart > 0) {
        scan = s42.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s42.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s42.match_length = MAX_MATCH - (strend - scan);
          if (s42.match_length > s42.lookahead) {
            s42.match_length = s42.lookahead;
          }
        }
      }
      if (s42.match_length >= MIN_MATCH) {
        bflush = trees._tr_tally(s42, 1, s42.match_length - MIN_MATCH);
        s42.lookahead -= s42.match_length;
        s42.strstart += s42.match_length;
        s42.match_length = 0;
      } else {
        bflush = trees._tr_tally(s42, 0, s42.window[s42.strstart]);
        s42.lookahead--;
        s42.strstart++;
      }
      if (bflush) {
        flush_block_only(s42, false);
        if (s42.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s42.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only(s42, true);
      if (s42.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s42.last_lit) {
      flush_block_only(s42, false);
      if (s42.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s42, flush) {
    var bflush;
    for (; ; ) {
      if (s42.lookahead === 0) {
        fill_window(s42);
        if (s42.lookahead === 0) {
          if (flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s42.match_length = 0;
      bflush = trees._tr_tally(s42, 0, s42.window[s42.strstart]);
      s42.lookahead--;
      s42.strstart++;
      if (bflush) {
        flush_block_only(s42, false);
        if (s42.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s42.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only(s42, true);
      if (s42.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s42.last_lit) {
      flush_block_only(s42, false);
      if (s42.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table;
  configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  function lm_init(s42) {
    s42.window_size = 2 * s42.w_size;
    zero(s42.head);
    s42.max_lazy_match = configuration_table[s42.level].max_lazy;
    s42.good_match = configuration_table[s42.level].good_length;
    s42.nice_match = configuration_table[s42.level].nice_length;
    s42.max_chain_length = configuration_table[s42.level].max_chain;
    s42.strstart = 0;
    s42.block_start = 0;
    s42.lookahead = 0;
    s42.insert = 0;
    s42.match_length = s42.prev_length = MIN_MATCH - 1;
    s42.match_available = 0;
    s42.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED2;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    this.heap = new utils.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s42;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR2);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN2;
    s42 = strm.state;
    s42.pending = 0;
    s42.pending_out = 0;
    if (s42.wrap < 0) {
      s42.wrap = -s42.wrap;
    }
    s42.status = s42.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s42.wrap === 2 ? 0 : 1;
    s42.last_flush = Z_NO_FLUSH2;
    trees._tr_init(s42);
    return Z_OK2;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK2) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR2;
    }
    strm.state.gzhead = head;
    return Z_OK2;
  }
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR2;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION2) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED2) {
      return err(strm, Z_STREAM_ERROR2);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s42 = new DeflateState();
    strm.state = s42;
    s42.strm = strm;
    s42.wrap = wrap;
    s42.gzhead = null;
    s42.w_bits = windowBits;
    s42.w_size = 1 << s42.w_bits;
    s42.w_mask = s42.w_size - 1;
    s42.hash_bits = memLevel + 7;
    s42.hash_size = 1 << s42.hash_bits;
    s42.hash_mask = s42.hash_size - 1;
    s42.hash_shift = ~~((s42.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s42.window = new utils.Buf8(s42.w_size * 2);
    s42.head = new utils.Buf16(s42.hash_size);
    s42.prev = new utils.Buf16(s42.w_size);
    s42.lit_bufsize = 1 << memLevel + 6;
    s42.pending_buf_size = s42.lit_bufsize * 4;
    s42.pending_buf = new utils.Buf8(s42.pending_buf_size);
    s42.d_buf = 1 * s42.lit_bufsize;
    s42.l_buf = (1 + 2) * s42.lit_bufsize;
    s42.level = level;
    s42.strategy = strategy;
    s42.method = method;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED2, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY2);
  }
  function deflate2(strm, flush) {
    var old_flush, s42;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK2 || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR2) : Z_STREAM_ERROR2;
    }
    s42 = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s42.status === FINISH_STATE && flush !== Z_FINISH2) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR2 : Z_STREAM_ERROR2);
    }
    s42.strm = strm;
    old_flush = s42.last_flush;
    s42.last_flush = flush;
    if (s42.status === INIT_STATE) {
      if (s42.wrap === 2) {
        strm.adler = 0;
        put_byte(s42, 31);
        put_byte(s42, 139);
        put_byte(s42, 8);
        if (!s42.gzhead) {
          put_byte(s42, 0);
          put_byte(s42, 0);
          put_byte(s42, 0);
          put_byte(s42, 0);
          put_byte(s42, 0);
          put_byte(s42, s42.level === 9 ? 2 : s42.strategy >= Z_HUFFMAN_ONLY2 || s42.level < 2 ? 4 : 0);
          put_byte(s42, OS_CODE);
          s42.status = BUSY_STATE;
        } else {
          put_byte(s42, (s42.gzhead.text ? 1 : 0) + (s42.gzhead.hcrc ? 2 : 0) + (!s42.gzhead.extra ? 0 : 4) + (!s42.gzhead.name ? 0 : 8) + (!s42.gzhead.comment ? 0 : 16));
          put_byte(s42, s42.gzhead.time & 255);
          put_byte(s42, s42.gzhead.time >> 8 & 255);
          put_byte(s42, s42.gzhead.time >> 16 & 255);
          put_byte(s42, s42.gzhead.time >> 24 & 255);
          put_byte(s42, s42.level === 9 ? 2 : s42.strategy >= Z_HUFFMAN_ONLY2 || s42.level < 2 ? 4 : 0);
          put_byte(s42, s42.gzhead.os & 255);
          if (s42.gzhead.extra && s42.gzhead.extra.length) {
            put_byte(s42, s42.gzhead.extra.length & 255);
            put_byte(s42, s42.gzhead.extra.length >> 8 & 255);
          }
          if (s42.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s42.pending_buf, s42.pending, 0);
          }
          s42.gzindex = 0;
          s42.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED2 + (s42.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s42.strategy >= Z_HUFFMAN_ONLY2 || s42.level < 2) {
          level_flags = 0;
        } else if (s42.level < 6) {
          level_flags = 1;
        } else if (s42.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s42.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s42.status = BUSY_STATE;
        putShortMSB(s42, header);
        if (s42.strstart !== 0) {
          putShortMSB(s42, strm.adler >>> 16);
          putShortMSB(s42, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s42.status === EXTRA_STATE) {
      if (s42.gzhead.extra) {
        beg = s42.pending;
        while (s42.gzindex < (s42.gzhead.extra.length & 65535)) {
          if (s42.pending === s42.pending_buf_size) {
            if (s42.gzhead.hcrc && s42.pending > beg) {
              strm.adler = crc32(strm.adler, s42.pending_buf, s42.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s42.pending;
            if (s42.pending === s42.pending_buf_size) {
              break;
            }
          }
          put_byte(s42, s42.gzhead.extra[s42.gzindex] & 255);
          s42.gzindex++;
        }
        if (s42.gzhead.hcrc && s42.pending > beg) {
          strm.adler = crc32(strm.adler, s42.pending_buf, s42.pending - beg, beg);
        }
        if (s42.gzindex === s42.gzhead.extra.length) {
          s42.gzindex = 0;
          s42.status = NAME_STATE;
        }
      } else {
        s42.status = NAME_STATE;
      }
    }
    if (s42.status === NAME_STATE) {
      if (s42.gzhead.name) {
        beg = s42.pending;
        do {
          if (s42.pending === s42.pending_buf_size) {
            if (s42.gzhead.hcrc && s42.pending > beg) {
              strm.adler = crc32(strm.adler, s42.pending_buf, s42.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s42.pending;
            if (s42.pending === s42.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s42.gzindex < s42.gzhead.name.length) {
            val = s42.gzhead.name.charCodeAt(s42.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s42, val);
        } while (val !== 0);
        if (s42.gzhead.hcrc && s42.pending > beg) {
          strm.adler = crc32(strm.adler, s42.pending_buf, s42.pending - beg, beg);
        }
        if (val === 0) {
          s42.gzindex = 0;
          s42.status = COMMENT_STATE;
        }
      } else {
        s42.status = COMMENT_STATE;
      }
    }
    if (s42.status === COMMENT_STATE) {
      if (s42.gzhead.comment) {
        beg = s42.pending;
        do {
          if (s42.pending === s42.pending_buf_size) {
            if (s42.gzhead.hcrc && s42.pending > beg) {
              strm.adler = crc32(strm.adler, s42.pending_buf, s42.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s42.pending;
            if (s42.pending === s42.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s42.gzindex < s42.gzhead.comment.length) {
            val = s42.gzhead.comment.charCodeAt(s42.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s42, val);
        } while (val !== 0);
        if (s42.gzhead.hcrc && s42.pending > beg) {
          strm.adler = crc32(strm.adler, s42.pending_buf, s42.pending - beg, beg);
        }
        if (val === 0) {
          s42.status = HCRC_STATE;
        }
      } else {
        s42.status = HCRC_STATE;
      }
    }
    if (s42.status === HCRC_STATE) {
      if (s42.gzhead.hcrc) {
        if (s42.pending + 2 > s42.pending_buf_size) {
          flush_pending(strm);
        }
        if (s42.pending + 2 <= s42.pending_buf_size) {
          put_byte(s42, strm.adler & 255);
          put_byte(s42, strm.adler >> 8 & 255);
          strm.adler = 0;
          s42.status = BUSY_STATE;
        }
      } else {
        s42.status = BUSY_STATE;
      }
    }
    if (s42.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s42.last_flush = -1;
        return Z_OK2;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH2) {
      return err(strm, Z_BUF_ERROR2);
    }
    if (s42.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR2);
    }
    if (strm.avail_in !== 0 || s42.lookahead !== 0 || flush !== Z_NO_FLUSH2 && s42.status !== FINISH_STATE) {
      var bstate = s42.strategy === Z_HUFFMAN_ONLY2 ? deflate_huff(s42, flush) : s42.strategy === Z_RLE2 ? deflate_rle(s42, flush) : configuration_table[s42.level].func(s42, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s42.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s42.last_flush = -1;
        }
        return Z_OK2;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH2) {
          trees._tr_align(s42);
        } else if (flush !== Z_BLOCK2) {
          trees._tr_stored_block(s42, 0, 0, false);
          if (flush === Z_FULL_FLUSH2) {
            zero(s42.head);
            if (s42.lookahead === 0) {
              s42.strstart = 0;
              s42.block_start = 0;
              s42.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s42.last_flush = -1;
          return Z_OK2;
        }
      }
    }
    if (flush !== Z_FINISH2) {
      return Z_OK2;
    }
    if (s42.wrap <= 0) {
      return Z_STREAM_END2;
    }
    if (s42.wrap === 2) {
      put_byte(s42, strm.adler & 255);
      put_byte(s42, strm.adler >> 8 & 255);
      put_byte(s42, strm.adler >> 16 & 255);
      put_byte(s42, strm.adler >> 24 & 255);
      put_byte(s42, strm.total_in & 255);
      put_byte(s42, strm.total_in >> 8 & 255);
      put_byte(s42, strm.total_in >> 16 & 255);
      put_byte(s42, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s42, strm.adler >>> 16);
      putShortMSB(s42, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s42.wrap > 0) {
      s42.wrap = -s42.wrap;
    }
    return s42.pending !== 0 ? Z_OK2 : Z_STREAM_END2;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR2);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR2) : Z_OK2;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s42;
    var str, n42;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    s42 = strm.state;
    wrap = s42.wrap;
    if (wrap === 2 || wrap === 1 && s42.status !== INIT_STATE || s42.lookahead) {
      return Z_STREAM_ERROR2;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s42.wrap = 0;
    if (dictLength >= s42.w_size) {
      if (wrap === 0) {
        zero(s42.head);
        s42.strstart = 0;
        s42.block_start = 0;
        s42.insert = 0;
      }
      tmpDict = new utils.Buf8(s42.w_size);
      utils.arraySet(tmpDict, dictionary, dictLength - s42.w_size, s42.w_size, 0);
      dictionary = tmpDict;
      dictLength = s42.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s42);
    while (s42.lookahead >= MIN_MATCH) {
      str = s42.strstart;
      n42 = s42.lookahead - (MIN_MATCH - 1);
      do {
        s42.ins_h = (s42.ins_h << s42.hash_shift ^ s42.window[str + MIN_MATCH - 1]) & s42.hash_mask;
        s42.prev[str & s42.w_mask] = s42.head[s42.ins_h];
        s42.head[s42.ins_h] = str;
        str++;
      } while (--n42);
      s42.strstart = str;
      s42.lookahead = MIN_MATCH - 1;
      fill_window(s42);
    }
    s42.strstart += s42.lookahead;
    s42.block_start = s42.strstart;
    s42.insert = s42.lookahead;
    s42.lookahead = 0;
    s42.match_length = s42.prev_length = MIN_MATCH - 1;
    s42.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s42.wrap = wrap;
    return Z_OK2;
  }
  exports$72.deflateInit = deflateInit;
  exports$72.deflateInit2 = deflateInit2;
  exports$72.deflateReset = deflateReset;
  exports$72.deflateResetKeep = deflateResetKeep;
  exports$72.deflateSetHeader = deflateSetHeader;
  exports$72.deflate = deflate2;
  exports$72.deflateEnd = deflateEnd;
  exports$72.deflateSetDictionary = deflateSetDictionary;
  exports$72.deflateInfo = "pako deflate (from Nodeca project)";
  return exports$72;
}
var exports$62 = {};
var _dewExec$52 = false;
function dew$52() {
  if (_dewExec$52) return exports$62;
  _dewExec$52 = true;
  var BAD = 30;
  var TYPE = 12;
  exports$62 = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top: do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen: for (; ; ) {
        op = here >>> 24;
        hold >>>= op;
        bits -= op;
        op = here >>> 16 & 255;
        if (op === 0) {
          output[_out++] = here & 65535;
        } else if (op & 16) {
          len = here & 65535;
          op &= 15;
          if (op) {
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
            }
            len += hold & (1 << op) - 1;
            hold >>>= op;
            bits -= op;
          }
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = dcode[hold & dmask];
          dodist: for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op & 16) {
              dist = here & 65535;
              op &= 15;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
              }
              dist += hold & (1 << op) - 1;
              if (dist > dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break top;
              }
              hold >>>= op;
              bits -= op;
              op = _out - beg;
              if (dist > op) {
                op = dist - op;
                if (op > whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break top;
                  }
                }
                from = 0;
                from_source = s_window;
                if (wnext === 0) {
                  from += wsize - op;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;
                    from_source = output;
                  }
                } else if (wnext < op) {
                  from += wsize + wnext - op;
                  op -= wnext;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = 0;
                    if (wnext < len) {
                      op = wnext;
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;
                      from_source = output;
                    }
                  }
                } else {
                  from += wnext - op;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;
                    from_source = output;
                  }
                }
                while (len > 2) {
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  len -= 3;
                }
                if (len) {
                  output[_out++] = from_source[from++];
                  if (len > 1) {
                    output[_out++] = from_source[from++];
                  }
                }
              } else {
                from = _out - dist;
                do {
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  len -= 3;
                } while (len > 2);
                if (len) {
                  output[_out++] = output[from++];
                  if (len > 1) {
                    output[_out++] = output[from++];
                  }
                }
              }
            } else if ((op & 64) === 0) {
              here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dodist;
            } else {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break top;
            }
            break;
          }
        } else if ((op & 64) === 0) {
          here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
          continue dolen;
        } else if (op & 32) {
          state.mode = TYPE;
          break top;
        } else {
          strm.msg = "invalid literal/length code";
          state.mode = BAD;
          break top;
        }
        break;
      }
    } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
  return exports$62;
}
var exports$52 = {};
var _dewExec$42 = false;
function dew$42() {
  if (_dewExec$42) return exports$52;
  _dewExec$42 = true;
  var utils = dew$b2();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  exports$52 = function inflate_table(type, lens, lens_index, codes2, table, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min = 0, max = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count = new utils.Buf16(MAXBITS + 1);
    var offs = new utils.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes2; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes2; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES) {
      base = extra = work;
      end = 19;
    } else if (type === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
  return exports$52;
}
var exports$42 = {};
var _dewExec$32 = false;
function dew$32() {
  if (_dewExec$32) return exports$42;
  _dewExec$32 = true;
  var utils = dew$b2();
  var adler32 = dew$92();
  var crc32 = dew$82();
  var inflate_fast = dew$52();
  var inflate_table = dew$42();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH2 = 4;
  var Z_BLOCK2 = 5;
  var Z_TREES2 = 6;
  var Z_OK2 = 0;
  var Z_STREAM_END2 = 1;
  var Z_NEED_DICT2 = 2;
  var Z_STREAM_ERROR2 = -2;
  var Z_DATA_ERROR2 = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR2 = -5;
  var Z_DEFLATED2 = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q3) {
    return (q3 >>> 24 & 255) + (q3 >>> 8 & 65280) + ((q3 & 65280) << 8) + ((q3 & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils.Buf16(320);
    this.work = new utils.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK2;
  }
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR2;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR2;
    }
    state = new InflateState();
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK2) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix, distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils.Buf32(512);
      distfix = new utils.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
        bits: 9
      });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
        bits: 5
      });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  function updatewindow(strm, src, end, copy) {
    var dist;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils.Buf8(state.wsize);
    }
    if (copy >= state.wsize) {
      utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      utils.arraySet(state.window, src, end - copy, dist, state.wnext);
      copy -= dist;
      if (copy) {
        utils.arraySet(state.window, src, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  function inflate2(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils.Buf8(4);
    var opts;
    var n42;
    var order = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK2;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED2) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED2) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          /* falls through */
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          /* falls through */
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          /* falls through */
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          /* falls through */
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(
                    state.head.extra,
                    input,
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          /* falls through */
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          /* falls through */
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          /* falls through */
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          /* falls through */
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT2;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          /* falls through */
          case TYPE:
            if (flush === Z_BLOCK2 || flush === Z_TREES2) {
              break inf_leave;
            }
          /* falls through */
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES2) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES2) {
              break inf_leave;
            }
          /* falls through */
          case COPY_:
            state.mode = COPY;
          /* falls through */
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          /* falls through */
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {
              bits: state.lenbits
            };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          /* falls through */
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n42 = here_bits + 2;
                  while (bits < n42) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n42 = here_bits + 3;
                  while (bits < n42) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n42 = here_bits + 7;
                  while (bits < n42) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = {
              bits: state.lenbits
            };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {
              bits: state.distbits
            };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES2) {
              break inf_leave;
            }
          /* falls through */
          case LEN_:
            state.mode = LEN;
          /* falls through */
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          /* falls through */
          case LENEXT:
            if (state.extra) {
              n42 = state.extra;
              while (bits < n42) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          /* falls through */
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          /* falls through */
          case DISTEXT:
            if (state.extra) {
              n42 = state.extra;
              while (bits < n42) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          /* falls through */
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          /* falls through */
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          /* falls through */
          case DONE:
            ret = Z_STREAM_END2;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR2;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          /* falls through */
          default:
            return Z_STREAM_ERROR2;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH2)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH2) && ret === Z_OK2) {
      ret = Z_BUF_ERROR2;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK2;
  }
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR2;
    }
    state.head = head;
    head.done = false;
    return Z_OK2;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR2;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR2;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK2;
  }
  exports$42.inflateReset = inflateReset;
  exports$42.inflateReset2 = inflateReset2;
  exports$42.inflateResetKeep = inflateResetKeep;
  exports$42.inflateInit = inflateInit;
  exports$42.inflateInit2 = inflateInit2;
  exports$42.inflate = inflate2;
  exports$42.inflateEnd = inflateEnd;
  exports$42.inflateGetHeader = inflateGetHeader;
  exports$42.inflateSetDictionary = inflateSetDictionary;
  exports$42.inflateInfo = "pako inflate (from Nodeca project)";
  return exports$42;
}
var exports$32 = {};
var _dewExec$23 = false;
function dew$23() {
  if (_dewExec$23) return exports$32;
  _dewExec$23 = true;
  exports$32 = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  return exports$32;
}
var exports$23 = {};
var _dewExec$13 = false;
function dew$13() {
  if (_dewExec$13) return exports$23;
  _dewExec$13 = true;
  var Buffer = dew().Buffer;
  var process$1 = process2;
  var assert2 = et;
  var Zstream = dew$c2();
  var zlib_deflate = dew$62();
  var zlib_inflate = dew$32();
  var constants = dew$23();
  for (var key in constants) {
    exports$23[key] = constants[key];
  }
  exports$23.NONE = 0;
  exports$23.DEFLATE = 1;
  exports$23.INFLATE = 2;
  exports$23.GZIP = 3;
  exports$23.GUNZIP = 4;
  exports$23.DEFLATERAW = 5;
  exports$23.INFLATERAW = 6;
  exports$23.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib2(mode) {
    if (typeof mode !== "number" || mode < exports$23.DEFLATE || mode > exports$23.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib2.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert2(this.init_done, "close before init");
    assert2(this.mode <= exports$23.UNZIP);
    if (this.mode === exports$23.DEFLATE || this.mode === exports$23.GZIP || this.mode === exports$23.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports$23.INFLATE || this.mode === exports$23.GUNZIP || this.mode === exports$23.INFLATERAW || this.mode === exports$23.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports$23.NONE;
    this.dictionary = null;
  };
  Zlib2.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib2.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib2.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert2.equal(arguments.length, 8);
    assert2(this.init_done, "write before init");
    assert2(this.mode !== exports$23.NONE, "already finalized");
    assert2.equal(false, this.write_in_progress, "write already in progress");
    assert2.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert2.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports$23.Z_NO_FLUSH && flush !== exports$23.Z_PARTIAL_FLUSH && flush !== exports$23.Z_SYNC_FLUSH && flush !== exports$23.Z_FULL_FLUSH && flush !== exports$23.Z_FINISH && flush !== exports$23.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    process$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib2.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib2.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports$23.DEFLATE:
      case exports$23.GZIP:
      case exports$23.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports$23.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports$23.INFLATE;
              break;
            }
          // fallthrough
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports$23.GUNZIP;
            } else {
              this.mode = exports$23.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      // fallthrough
      case exports$23.INFLATE:
      case exports$23.GUNZIP:
      case exports$23.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports$23.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports$23.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports$23.Z_DATA_ERROR) {
            this.err = exports$23.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports$23.GUNZIP && this.err === exports$23.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib2.prototype._checkError = function() {
    switch (this.err) {
      case exports$23.Z_OK:
      case exports$23.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports$23.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports$23.Z_STREAM_END:
        break;
      case exports$23.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib2.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib2.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib2.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert2(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert2(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert2(level >= -1 && level <= 9, "invalid compression level");
    assert2(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert2(strategy === exports$23.Z_FILTERED || strategy === exports$23.Z_HUFFMAN_ONLY || strategy === exports$23.Z_RLE || strategy === exports$23.Z_FIXED || strategy === exports$23.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib2.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib2.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib2.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports$23.Z_NO_FLUSH;
    this.err = exports$23.Z_OK;
    if (this.mode === exports$23.GZIP || this.mode === exports$23.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports$23.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports$23.DEFLATERAW || this.mode === exports$23.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports$23.DEFLATE:
      case exports$23.GZIP:
      case exports$23.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports$23.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports$23.INFLATE:
      case exports$23.GUNZIP:
      case exports$23.INFLATERAW:
      case exports$23.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports$23.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib2.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports$23.Z_OK;
    switch (this.mode) {
      case exports$23.DEFLATE:
      case exports$23.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports$23.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib2.prototype._reset = function() {
    this.err = exports$23.Z_OK;
    switch (this.mode) {
      case exports$23.DEFLATE:
      case exports$23.DEFLATERAW:
      case exports$23.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports$23.INFLATE:
      case exports$23.INFLATERAW:
      case exports$23.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports$23.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports$23.Zlib = Zlib2;
  return exports$23;
}
var exports$14 = {};
var _dewExec5 = false;
function dew5() {
  if (_dewExec5) return exports$14;
  _dewExec5 = true;
  var process$1 = process2;
  var Buffer = dew().Buffer;
  var Transform = exports4.Transform;
  var binding2 = dew$13();
  var util = X;
  var assert2 = et.ok;
  var kMaxLength = dew().kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes";
  binding2.Z_MIN_WINDOWBITS = 8;
  binding2.Z_MAX_WINDOWBITS = 15;
  binding2.Z_DEFAULT_WINDOWBITS = 15;
  binding2.Z_MIN_CHUNK = 64;
  binding2.Z_MAX_CHUNK = Infinity;
  binding2.Z_DEFAULT_CHUNK = 16 * 1024;
  binding2.Z_MIN_MEMLEVEL = 1;
  binding2.Z_MAX_MEMLEVEL = 9;
  binding2.Z_DEFAULT_MEMLEVEL = 8;
  binding2.Z_MIN_LEVEL = -1;
  binding2.Z_MAX_LEVEL = 9;
  binding2.Z_DEFAULT_LEVEL = binding2.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding2);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports$14, bkey, {
        enumerable: true,
        value: binding2[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding2.Z_OK,
    Z_STREAM_END: binding2.Z_STREAM_END,
    Z_NEED_DICT: binding2.Z_NEED_DICT,
    Z_ERRNO: binding2.Z_ERRNO,
    Z_STREAM_ERROR: binding2.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding2.Z_DATA_ERROR,
    Z_MEM_ERROR: binding2.Z_MEM_ERROR,
    Z_BUF_ERROR: binding2.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding2.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports$14, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports$14.Deflate = Deflate2;
  exports$14.Inflate = Inflate2;
  exports$14.Gzip = Gzip2;
  exports$14.Gunzip = Gunzip2;
  exports$14.DeflateRaw = DeflateRaw2;
  exports$14.InflateRaw = InflateRaw2;
  exports$14.Unzip = Unzip2;
  exports$14.createDeflate = function(o42) {
    return new Deflate2(o42);
  };
  exports$14.createInflate = function(o42) {
    return new Inflate2(o42);
  };
  exports$14.createDeflateRaw = function(o42) {
    return new DeflateRaw2(o42);
  };
  exports$14.createInflateRaw = function(o42) {
    return new InflateRaw2(o42);
  };
  exports$14.createGzip = function(o42) {
    return new Gzip2(o42);
  };
  exports$14.createGunzip = function(o42) {
    return new Gunzip2(o42);
  };
  exports$14.createUnzip = function(o42) {
    return new Unzip2(o42);
  };
  exports$14.deflate = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Deflate2(opts), buffer2, callback);
  };
  exports$14.deflateSync = function(buffer2, opts) {
    return zlibBufferSync(new Deflate2(opts), buffer2);
  };
  exports$14.gzip = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Gzip2(opts), buffer2, callback);
  };
  exports$14.gzipSync = function(buffer2, opts) {
    return zlibBufferSync(new Gzip2(opts), buffer2);
  };
  exports$14.deflateRaw = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new DeflateRaw2(opts), buffer2, callback);
  };
  exports$14.deflateRawSync = function(buffer2, opts) {
    return zlibBufferSync(new DeflateRaw2(opts), buffer2);
  };
  exports$14.unzip = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Unzip2(opts), buffer2, callback);
  };
  exports$14.unzipSync = function(buffer2, opts) {
    return zlibBufferSync(new Unzip2(opts), buffer2);
  };
  exports$14.inflate = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Inflate2(opts), buffer2, callback);
  };
  exports$14.inflateSync = function(buffer2, opts) {
    return zlibBufferSync(new Inflate2(opts), buffer2);
  };
  exports$14.gunzip = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new Gunzip2(opts), buffer2, callback);
  };
  exports$14.gunzipSync = function(buffer2, opts) {
    return zlibBufferSync(new Gunzip2(opts), buffer2);
  };
  exports$14.inflateRaw = function(buffer2, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = {};
    }
    return zlibBuffer(new InflateRaw2(opts), buffer2, callback);
  };
  exports$14.inflateRawSync = function(buffer2, opts) {
    return zlibBufferSync(new InflateRaw2(opts), buffer2);
  };
  function zlibBuffer(engine, buffer2, callback) {
    var buffers = [];
    var nread = 0;
    engine.on("error", onError);
    engine.on("end", onEnd);
    engine.end(buffer2);
    flow();
    function flow() {
      var chunk;
      while (null !== (chunk = engine.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine.once("readable", flow);
    }
    function onError(err) {
      engine.removeListener("end", onEnd);
      engine.removeListener("readable", flow);
      callback(err);
    }
    function onEnd() {
      var buf;
      var err = null;
      if (nread >= kMaxLength) {
        err = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer.concat(buffers, nread);
      }
      buffers = [];
      engine.close();
      callback(err, buf);
    }
  }
  function zlibBufferSync(engine, buffer2) {
    if (typeof buffer2 === "string") buffer2 = Buffer.from(buffer2);
    if (!Buffer.isBuffer(buffer2)) throw new TypeError("Not a string or buffer");
    var flushFlag = engine._finishFlushFlag;
    return engine._processChunk(buffer2, flushFlag);
  }
  function Deflate2(opts) {
    if (!(this instanceof Deflate2)) return new Deflate2(opts);
    Zlib2.call(this, opts, binding2.DEFLATE);
  }
  function Inflate2(opts) {
    if (!(this instanceof Inflate2)) return new Inflate2(opts);
    Zlib2.call(this, opts, binding2.INFLATE);
  }
  function Gzip2(opts) {
    if (!(this instanceof Gzip2)) return new Gzip2(opts);
    Zlib2.call(this, opts, binding2.GZIP);
  }
  function Gunzip2(opts) {
    if (!(this instanceof Gunzip2)) return new Gunzip2(opts);
    Zlib2.call(this, opts, binding2.GUNZIP);
  }
  function DeflateRaw2(opts) {
    if (!(this instanceof DeflateRaw2)) return new DeflateRaw2(opts);
    Zlib2.call(this, opts, binding2.DEFLATERAW);
  }
  function InflateRaw2(opts) {
    if (!(this instanceof InflateRaw2)) return new InflateRaw2(opts);
    Zlib2.call(this, opts, binding2.INFLATERAW);
  }
  function Unzip2(opts) {
    if (!(this instanceof Unzip2)) return new Unzip2(opts);
    Zlib2.call(this, opts, binding2.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding2.Z_NO_FLUSH || flag === binding2.Z_PARTIAL_FLUSH || flag === binding2.Z_SYNC_FLUSH || flag === binding2.Z_FULL_FLUSH || flag === binding2.Z_FINISH || flag === binding2.Z_BLOCK;
  }
  function Zlib2(opts, mode) {
    var _this = this;
    this._opts = opts = opts || {};
    this._chunkSize = opts.chunkSize || exports$14.Z_DEFAULT_CHUNK;
    Transform.call(this, opts);
    if (opts.flush && !isValidFlushFlag(opts.flush)) {
      throw new Error("Invalid flush flag: " + opts.flush);
    }
    if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts.finishFlush);
    }
    this._flushFlag = opts.flush || binding2.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding2.Z_FINISH;
    if (opts.chunkSize) {
      if (opts.chunkSize < exports$14.Z_MIN_CHUNK || opts.chunkSize > exports$14.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts.chunkSize);
      }
    }
    if (opts.windowBits) {
      if (opts.windowBits < exports$14.Z_MIN_WINDOWBITS || opts.windowBits > exports$14.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts.windowBits);
      }
    }
    if (opts.level) {
      if (opts.level < exports$14.Z_MIN_LEVEL || opts.level > exports$14.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts.level);
      }
    }
    if (opts.memLevel) {
      if (opts.memLevel < exports$14.Z_MIN_MEMLEVEL || opts.memLevel > exports$14.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts.memLevel);
      }
    }
    if (opts.strategy) {
      if (opts.strategy != exports$14.Z_FILTERED && opts.strategy != exports$14.Z_HUFFMAN_ONLY && opts.strategy != exports$14.Z_RLE && opts.strategy != exports$14.Z_FIXED && opts.strategy != exports$14.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts.strategy);
      }
    }
    if (opts.dictionary) {
      if (!Buffer.isBuffer(opts.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding2.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports$14.codes[errno];
      self2.emit("error", error);
    };
    var level = exports$14.Z_DEFAULT_COMPRESSION;
    if (typeof opts.level === "number") level = opts.level;
    var strategy = exports$14.Z_DEFAULT_STRATEGY;
    if (typeof opts.strategy === "number") strategy = opts.strategy;
    this._handle.init(opts.windowBits || exports$14.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports$14.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
    this._buffer = Buffer.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util.inherits(Zlib2, Transform);
  Zlib2.prototype.params = function(level, strategy, callback) {
    if (level < exports$14.Z_MIN_LEVEL || level > exports$14.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports$14.Z_FILTERED && strategy != exports$14.Z_HUFFMAN_ONLY && strategy != exports$14.Z_RLE && strategy != exports$14.Z_FIXED && strategy != exports$14.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding2.Z_SYNC_FLUSH, function() {
        assert2(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback) callback();
        }
      });
    } else {
      process$1.nextTick(callback);
    }
  };
  Zlib2.prototype.reset = function() {
    assert2(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib2.prototype._flush = function(callback) {
    this._transform(Buffer.alloc(0), "", callback);
  };
  Zlib2.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding2.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback) process$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback) this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer.alloc(0), "", callback);
    }
  };
  Zlib2.prototype.close = function(callback) {
    _close(this, callback);
    process$1.nextTick(emitCloseNT, this);
  };
  function _close(engine, callback) {
    if (callback) process$1.nextTick(callback);
    if (!engine._handle) return;
    engine._handle.close();
    engine._handle = null;
  }
  function emitCloseNT(self2) {
    self2.emit("close");
  }
  Zlib2.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error("invalid input"));
    if (!this._handle) return cb(new Error("zlib binding closed"));
    if (last) flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding2.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib2.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er) {
        error = er;
      });
      assert2(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert2(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError) return;
      var have = availOutBefore - availOutAfter;
      assert2(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async) return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async) return false;
      cb();
    }
  };
  util.inherits(Deflate2, Zlib2);
  util.inherits(Inflate2, Zlib2);
  util.inherits(Gzip2, Zlib2);
  util.inherits(Gunzip2, Zlib2);
  util.inherits(DeflateRaw2, Zlib2);
  util.inherits(InflateRaw2, Zlib2);
  util.inherits(Unzip2, Zlib2);
  return exports$14;
}
var exports5 = dew5();
exports5["codes"];
exports5["Deflate"];
exports5["Inflate"];
exports5["Gzip"];
exports5["Gunzip"];
exports5["DeflateRaw"];
exports5["InflateRaw"];
exports5["Unzip"];
exports5["createDeflate"];
exports5["createInflate"];
exports5["createDeflateRaw"];
exports5["createInflateRaw"];
exports5["createGzip"];
exports5["createGunzip"];
exports5["createUnzip"];
exports5["deflate"];
exports5["deflateSync"];
exports5["gzip"];
exports5["gzipSync"];
exports5["deflateRaw"];
exports5["deflateRawSync"];
exports5["unzip"];
exports5["unzipSync"];
exports5["inflate"];
exports5["inflateSync"];
exports5["gunzip"];
exports5["gunzipSync"];
exports5["inflateRaw"];
exports5["inflateRawSync"];
var Deflate = exports5.Deflate;
var DeflateRaw = exports5.DeflateRaw;
var Gunzip = exports5.Gunzip;
var Gzip = exports5.Gzip;
var Inflate = exports5.Inflate;
var InflateRaw = exports5.InflateRaw;
var Unzip = exports5.Unzip;
var Z_BEST_COMPRESSION = exports5.Z_BEST_COMPRESSION;
var Z_BEST_SPEED = exports5.Z_BEST_SPEED;
var Z_BINARY = exports5.Z_BINARY;
var Z_BLOCK = exports5.Z_BLOCK;
var Z_BUF_ERROR = exports5.Z_BUF_ERROR;
var Z_DATA_ERROR = exports5.Z_DATA_ERROR;
var Z_DEFAULT_CHUNK = exports5.Z_DEFAULT_CHUNK;
var Z_DEFAULT_COMPRESSION = exports5.Z_DEFAULT_COMPRESSION;
var Z_DEFAULT_LEVEL = exports5.Z_DEFAULT_LEVEL;
var Z_DEFAULT_MEMLEVEL = exports5.Z_DEFAULT_MEMLEVEL;
var Z_DEFAULT_STRATEGY = exports5.Z_DEFAULT_STRATEGY;
var Z_DEFAULT_WINDOWBITS = exports5.Z_DEFAULT_WINDOWBITS;
var Z_DEFLATED = exports5.Z_DEFLATED;
var Z_ERRNO = exports5.Z_ERRNO;
var Z_FILTERED = exports5.Z_FILTERED;
var Z_FINISH = exports5.Z_FINISH;
var Z_FIXED = exports5.Z_FIXED;
var Z_FULL_FLUSH = exports5.Z_FULL_FLUSH;
var Z_HUFFMAN_ONLY = exports5.Z_HUFFMAN_ONLY;
var Z_MAX_CHUNK = exports5.Z_MAX_CHUNK;
var Z_MAX_LEVEL = exports5.Z_MAX_LEVEL;
var Z_MAX_MEMLEVEL = exports5.Z_MAX_MEMLEVEL;
var Z_MAX_WINDOWBITS = exports5.Z_MAX_WINDOWBITS;
var Z_MIN_CHUNK = exports5.Z_MIN_CHUNK;
var Z_MIN_LEVEL = exports5.Z_MIN_LEVEL;
var Z_MIN_MEMLEVEL = exports5.Z_MIN_MEMLEVEL;
var Z_MIN_WINDOWBITS = exports5.Z_MIN_WINDOWBITS;
var Z_NEED_DICT = exports5.Z_NEED_DICT;
var Z_NO_COMPRESSION = exports5.Z_NO_COMPRESSION;
var Z_NO_FLUSH = exports5.Z_NO_FLUSH;
var Z_OK = exports5.Z_OK;
var Z_PARTIAL_FLUSH = exports5.Z_PARTIAL_FLUSH;
var Z_RLE = exports5.Z_RLE;
var Z_STREAM_END = exports5.Z_STREAM_END;
var Z_STREAM_ERROR = exports5.Z_STREAM_ERROR;
var Z_SYNC_FLUSH = exports5.Z_SYNC_FLUSH;
var Z_TEXT = exports5.Z_TEXT;
var Z_TREES = exports5.Z_TREES;
var Z_UNKNOWN = exports5.Z_UNKNOWN;
var Zlib = exports5.Zlib;
var codes = exports5.codes;
var createDeflate = exports5.createDeflate;
var createDeflateRaw = exports5.createDeflateRaw;
var createGunzip = exports5.createGunzip;
var createGzip = exports5.createGzip;
var createInflate = exports5.createInflate;
var createInflateRaw = exports5.createInflateRaw;
var createUnzip = exports5.createUnzip;
var deflate = exports5.deflate;
var deflateRaw = exports5.deflateRaw;
var deflateRawSync = exports5.deflateRawSync;
var deflateSync = exports5.deflateSync;
var gunzip = exports5.gunzip;
var gunzipSync = exports5.gunzipSync;
var gzip = exports5.gzip;
var gzipSync = exports5.gzipSync;
var inflate = exports5.inflate;
var inflateRaw = exports5.inflateRaw;
var inflateRawSync = exports5.inflateRawSync;
var inflateSync = exports5.inflateSync;
var unzip = exports5.unzip;
var unzipSync = exports5.unzipSync;

// tests/fixtures/input/unusedImport/zlib.ts
console.log(deflate);
/*! Bundled license information:

@jspm/core/nodelibs/browser/chunk-DtuTasat.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@jspm/core/nodelibs/browser/chunk-B738Er4n.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@jspm/core/nodelibs/browser/chunk-CjPlbOtt.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
*/
"
`;
